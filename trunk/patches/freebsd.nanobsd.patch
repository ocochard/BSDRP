--- nanobsd.sh.orig	2010-12-21 18:09:25.000000000 +0100
+++ nanobsd.sh	2011-12-13 23:56:40.000000000 +0100
@@ -24,7 +24,7 @@
 # OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 # SUCH DAMAGE.
 #
-# $FreeBSD: src/tools/tools/nanobsd/nanobsd.sh,v 1.51.2.4.2.1 2010/12/21 17:09:25 kensmith Exp $
+# $FreeBSD: src/tools/tools/nanobsd/nanobsd.sh,v 1.77 2011/05/31 17:14:06 imp Exp $
 #
 
 set -e
@@ -75,6 +75,9 @@
 # Kernel config file to use
 NANO_KERNEL=GENERIC
 
+# Kernel modules to build; default is none
+NANO_MODULES=
+
 # Customize commands.
 NANO_CUSTOMIZE=""
 
@@ -88,7 +91,7 @@
 NANO_DRIVE=ad0
 
 # Target media size in 512 bytes sectors
-NANO_MEDIASIZE=1200000
+NANO_MEDIASIZE=1500000
 
 # Number of code images on media (1 or 2)
 NANO_IMAGES=2
@@ -132,17 +135,33 @@
 # Can be "file" or "swap"
 NANO_MD_BACKING="file"
 
+# for swap type md(4) backing, write out the mbr only
+NANO_IMAGE_MBRONLY=true
+
 # Progress Print level
 PPLEVEL=3
 
+# Set NANO_LABEL to non-blank to form the basis for using /dev/ufs/label
+# in preference to /dev/${NANO_DRIVE}
+# Root partition will be ${NANO_LABEL}s{1,2}
+# /cfg partition will be ${NANO_LABEL}s3
+# /data partition will be ${NANO_LABEL}s4
+NANO_LABEL=""
+
 #######################################################################
 # Architecture to build.  Corresponds to TARGET_ARCH in a buildworld.
-# Unfortunately, there's no way to set TARGET at this time, and it 
+# Unfortunately, there's no way to set TARGET at this time, and it
 # conflates the two, so architectures where TARGET != TARGET_ARCH do
 # not work.  This defaults to the arch of the current machine.
 
 NANO_ARCH=`uname -p`
 
+# Directory to populate /cfg from
+NANO_CFGDIR=""
+
+# Directory to populate /data from
+NANO_DATADIR=""
+
 #######################################################################
 #
 # The functions which do the real work.
@@ -150,6 +169,13 @@
 #
 #######################################################################
 
+nano_cleanup() {
+   if [ $? -ne 0 ]; then
+       echo "Error encountered.  Check for errors in last log file." 1>&2
+    fi
+    exit $?
+}
+
 clean_build ( ) (
 	pprint 2 "Clean and create object directory (${MAKEOBJDIRPREFIX})"
 
@@ -166,6 +192,7 @@
 
 	echo "${CONF_WORLD}" > ${NANO_MAKE_CONF_BUILD}
 	echo "${CONF_BUILD}" >> ${NANO_MAKE_CONF_BUILD}
+	echo "SRCCONF=/dev/null" >> ${NANO_MAKE_CONF_BUILD}
 )
 
 build_world ( ) (
@@ -182,19 +209,26 @@
 	pprint 2 "build kernel ($NANO_KERNEL)"
 	pprint 3 "log: ${MAKEOBJDIRPREFIX}/_.bk"
 
+	(
 	if [ -f ${NANO_KERNEL} ] ; then
-		cp ${NANO_KERNEL} ${NANO_SRC}/sys/${NANO_ARCH}/conf
+		kernconfdir=$(realpath $(dirname ${NANO_KERNEL}))
+		kernconf=$(basename ${NANO_KERNEL})
+	else
+		kernconf=${NANO_KERNEL}
 	fi
 
-	(cd ${NANO_SRC};
+	cd ${NANO_SRC};
 	# unset these just in case to avoid compiler complaints
 	# when cross-building
 	unset TARGET_CPUTYPE
 	unset TARGET_BIG_ENDIAN
+	# Note: We intentionally build all modules, not only the ones in
+	# NANO_MODULES so the built world can be reused by multiple images.
 	env TARGET_ARCH=${NANO_ARCH} ${NANO_PMAKE} buildkernel \
-		__MAKE_CONF=${NANO_MAKE_CONF_BUILD} KERNCONF=`basename ${NANO_KERNEL}` \
-		> ${MAKEOBJDIRPREFIX}/_.bk 2>&1
-	)
+		__MAKE_CONF=${NANO_MAKE_CONF_BUILD} \
+		${kernconfdir:+"KERNCONFDIR="}${kernconfdir} \
+		KERNCONF=${kernconf}
+	) > ${MAKEOBJDIRPREFIX}/_.bk 2>&1
 )
 
 clean_world ( ) (
@@ -221,6 +255,7 @@
 
 	echo "${CONF_WORLD}" > ${NANO_MAKE_CONF_INSTALL}
 	echo "${CONF_INSTALL}" >> ${NANO_MAKE_CONF_INSTALL}
+	echo "SRCCONF=/dev/null" >> ${NANO_MAKE_CONF_INSTALL}
 )
 
 install_world ( ) (
@@ -251,14 +286,25 @@
 )
 
 install_kernel ( ) (
-	pprint 2 "install kernel"
+	pprint 2 "install kernel ($NANO_KERNEL)"
 	pprint 3 "log: ${NANO_OBJ}/_.ik"
 
+	(
+	if [ -f ${NANO_KERNEL} ] ; then
+		kernconfdir=$(realpath $(dirname ${NANO_KERNEL}))
+		kernconf=$(basename ${NANO_KERNEL})
+	else
+		kernconf=${NANO_KERNEL}
+	fi
+
 	cd ${NANO_SRC}
 	env TARGET_ARCH=${NANO_ARCH} ${NANO_PMAKE} installkernel \
 		DESTDIR=${NANO_WORLDDIR} \
-		__MAKE_CONF=${NANO_MAKE_CONF_INSTALL} KERNCONF=`basename ${NANO_KERNEL}` \
-		> ${NANO_OBJ}/_.ik 2>&1
+		__MAKE_CONF=${NANO_MAKE_CONF_INSTALL} \
+		${kernconfdir:+"KERNCONFDIR="}${kernconfdir} \
+		KERNCONF=${kernconf} \
+		MODULES_OVERRIDE="${NANO_MODULES}"
+	) > ${NANO_OBJ}/_.ik 2>&1
 )
 
 run_customize() (
@@ -269,7 +315,7 @@
 		pprint 2 "customize \"$c\""
 		pprint 3 "log: ${NANO_OBJ}/_.cust.$c"
 		pprint 4 "`type $c`"
-		( $c ) > ${NANO_OBJ}/_.cust.$c 2>&1
+		( set -x ; $c ) > ${NANO_OBJ}/_.cust.$c 2>&1
 	done
 )
 
@@ -281,7 +327,7 @@
 		pprint 2 "late customize \"$c\""
 		pprint 3 "log: ${NANO_OBJ}/_.late_cust.$c"
 		pprint 4 "`type $c`"
-		( $c ) > ${NANO_OBJ}/_.late_cust.$c 2>&1
+		( set -x ; $c ) > ${NANO_OBJ}/_.late_cust.$c 2>&1
 	done
 )
 
@@ -354,23 +400,33 @@
 prune_usr() (
 
 	# Remove all empty directories in /usr 
-	find ${NANO_WORLDDIR}/usr -type d -depth -print |
+	find ${NANO_WORLDDIR}/usr -type d -depth -not -name aout -print |
 		while read d
 		do
 			rmdir $d > /dev/null 2>&1 || true 
 		done
 )
 
+newfs_part ( ) (
+	local dev mnt lbl
+	dev=$1
+	mnt=$2
+	lbl=$3
+	echo newfs ${NANO_NEWFS} ${NANO_LABEL:+-L${NANO_LABEL}${lbl}} ${dev}
+	newfs ${NANO_NEWFS} ${NANO_LABEL:+-L${NANO_LABEL}${lbl}} ${dev}
+	mount -o async ${dev} ${mnt}
+)
+
 populate_slice ( ) (
-	local dev dir mnt
+	local dev dir mnt lbl
 	dev=$1
 	dir=$2
 	mnt=$3
-	test -z $2 && dir=/var/empty
-	test -d $d || dir=/var/empty
+	lbl=$4
+	test -z $2 && dir=${NANO_WORLDDIR}/var/empty
+	test -d $dir || dir=${NANO_WORLDDIR}/var/empty
 	echo "Creating ${dev} with ${dir} (mounting on ${mnt})"
-	newfs ${NANO_NEWFS} ${dev}
-	mount ${dev} ${mnt}
+	newfs_part $dev $mnt $lbl
 	cd ${dir}
 	find . -print | grep -Ev '/(CVS|\.svn)' | cpio -dumpv ${mnt}
 	df -i ${mnt}
@@ -378,11 +434,27 @@
 )
 
 populate_cfg_slice ( ) (
-	populate_slice "$1" "$2" "$3"
+	populate_slice "$1" "$2" "$3" "$4"
 )
 
 populate_data_slice ( ) (
-	populate_slice "$1" "$2" "$3"
+	populate_slice "$1" "$2" "$3" "$4"
+)
+
+generating_mtree ( ) (
+	local md mnt
+	md=$1
+	mnt=$2
+	mount ${md}s1a ${mnt}
+    echo "Generating mtree..."
+    echo "./etc" > ${NANO_OBJ}/mtree-exclude
+    echo "./var" >> ${NANO_OBJ}/mtree-exclude
+    echo "./tmp" >> ${NANO_OBJ}/mtree-exclude
+    echo "./dev" >> ${NANO_OBJ}/mtree-exclude
+    ( cd ${mnt} && mtree -x -ic -k flags,gid,mode,nlink,size,link,uid,sha256digest -X ${NANO_OBJ}/mtree-exclude ) > ${NANO_OBJ}/_.mtree
+
+    ( cd ${mnt} && du -k ) > ${NANO_OBJ}/_.du
+    umount ${mnt}
 )
 
 create_i386_diskimage ( ) (
@@ -467,8 +539,8 @@
 			-y ${NANO_HEADS}`
 	else
 		echo "Creating md backing file..."
-		dd if=/dev/zero of=${IMG} bs=${NANO_SECTS}b \
-			count=`expr ${NANO_MEDIASIZE} / ${NANO_SECTS}`
+		rm -f ${IMG}
+		dd if=/dev/zero of=${IMG} seek=${NANO_MEDIASIZE} count=0
 		MD=`mdconfig -a -t vnode -f ${IMG} -x ${NANO_SECTS} \
 			-y ${NANO_HEADS}`
 	fi
@@ -484,17 +556,9 @@
 	bsdlabel ${MD}s1
 
 	# Create first image
-	# XXX: should use populate_slice for easier override
-	newfs ${NANO_NEWFS} /dev/${MD}s1a
-	mount /dev/${MD}s1a ${MNT}
-	df -i ${MNT}
-	echo "Copying worlddir..."
-	( cd ${NANO_WORLDDIR} && find . -print | cpio -dump ${MNT} )
-	df -i ${MNT}
-	echo "Generating mtree..."
-	( cd ${MNT} && mtree -c ) > ${NANO_OBJ}/_.mtree
-	( cd ${MNT} && du -k ) > ${NANO_OBJ}/_.du
-	umount ${MNT}
+	populate_slice /dev/${MD}s1a ${NANO_WORLDDIR} ${MNT} "s1a"
+
+	generate_mtree /dev/${MD}s1a ${MNT}
 
 	if [ $NANO_IMAGES -gt 1 -a $NANO_INIT_IMG2 -gt 0 ] ; then
 		# Duplicate to second image (if present)
@@ -506,26 +570,39 @@
 			sed -i "" "s=${NANO_DRIVE}s1=${NANO_DRIVE}s2=g" $f
 		done
 		umount ${MNT}
+		# Override the label from the first partition so we
+		# don't confuse glabel with duplicates.
+		if [ ! -z ${NANO_LABEL} ]; then
+			tunefs -L ${NANO_LABEL}"s2a" /dev/${MD}s2a
+		fi
 	fi
 	
 	# Create Config slice
-	populate_cfg_slice /dev/${MD}s3 "${NANO_CFGDIR}" ${MNT}
+	populate_cfg_slice /dev/${MD}s3 "${NANO_CFGDIR}" ${MNT} "s3"
 
 	# Create Data slice, if any.
 	if [ $NANO_DATASIZE -ne 0 ] ; then
-		populate_data_slice /dev/${MD}s4 "${NANO_DATADIR}" ${MNT}
+		populate_data_slice /dev/${MD}s4 "${NANO_DATADIR}" ${MNT} "s4"
 	fi
 
 	if [ "${NANO_MD_BACKING}" = "swap" ] ; then
-		echo "Writing out ${NANO_IMGNAME}..."
-		dd if=/dev/${MD} of=${IMG} bs=64k
+		if [ ${NANO_IMAGE_MBRONLY} ]; then
+			echo "Writing out _.disk.mbr..."
+			dd if=/dev/${MD} of=${NANO_DISKIMGDIR}/_.disk.mbr bs=512 count=1
+		else
+			echo "Writing out ${NANO_IMGNAME}..."
+			dd if=/dev/${MD} of=${IMG} bs=64k
+		fi
 	fi
 
-	echo "Writing out _.disk.image..."
-	dd if=/dev/${MD}s1 of=${NANO_DISKIMGDIR}/_.disk.image bs=64k
+	if ${do_copyout_partition} ; then
+		echo "Writing out _.disk.image..."
+		dd if=/dev/${MD}s1 of=${NANO_DISKIMGDIR}/_.disk.image bs=64k
+	fi
 	mdconfig -d -u $MD
 
 	trap - 1 2 15 EXIT
+	trap "nano_cleanup" EXIT
 
 	) > ${NANO_OBJ}/_.di 2>&1
 )
@@ -535,6 +612,306 @@
 	create_i386_diskimage
 )
 
+# This function need to be adapted to the new nanobsd !!
+create_arm_diskimage()
+{
+    pprint 2 "build diskimage"
+    pprint 3 "log: ${MAKEOBJDIRPREFIX}/_.di"
+
+    (
+    echo "NANO_MEDIASIZE:   $NANO_MEDIASIZE"
+    echo "NANO_IMAGES:  $NANO_IMAGES"
+    echo "NANO_SECTS:   $NANO_SECTS"
+    echo "NANO_HEADS:   $NANO_HEADS"
+    echo "NANO_CODESIZE:    $NANO_CODESIZE"
+    echo "NANO_CONFSIZE:    $NANO_CONFSIZE"
+    echo "NANO_DATASIZE:    $NANO_DATASIZE"
+
+    echo $NANO_MEDIASIZE $NANO_IMAGES \
+        $NANO_SECTS $NANO_HEADS \
+        $NANO_CODESIZE $NANO_CONFSIZE $NANO_DATASIZE |
+    awk '
+    {
+        printf "# %s\n", $0
+
+        # size of cylinder in sectors
+        cs = $3 * $4
+
+        # number of full cylinders on media
+        cyl = int ($1 / cs)
+
+        # output fdisk geometry spec, truncate cyls to 1023
+        if (cyl <= 1023)
+            print "g c" cyl " h" $4 " s" $3
+        else
+            print "g c" 1023 " h" $4 " s" $3
+if ($7 > 0) {
+            # size of data partition in full cylinders
+            dsl = int (($7 + cs - 1) / cs)
+        } else {
+            dsl = 0;
+        }
+
+        # size of config partition in full cylinders
+        csl = int (($6 + cs - 1) / cs)
+
+        if ($5 == 0) {
+            # size of image partition(s) in full cylinders
+            isl = int ((cyl - dsl - csl) / $2)
+        } else {
+            isl = int (($5 + cs - 1) / cs)
+        }
+
+        # First image partition start at second track
+        print "p 1 165 " $3, isl * cs - $3
+        c = isl * cs;
+
+        # Second image partition (if any) also starts offset one 
+        # track to keep them identical.
+        if ($2 > 1) {
+            print "p 2 165 " $3 + c, isl * cs - $3
+            c += isl * cs;
+        }
+
+        # Config partition starts at cylinder boundary.
+        print "p 3 165 " c, csl * cs
+        c += csl * cs
+		
+		# Data partition (if any) starts at cylinder boundary.
+        if ($7 > 0) {
+            print "p 4 165 " c, dsl * cs
+        } else if ($7 < 0 && $1 > c) {
+            print "p 4 165 " c, $1 - c
+        } else if ($1 < c) {
+            print "Disk space overcommitted by", \
+                c - $1, "sectors" > "/dev/stderr"
+            exit 2
+        }
+
+        # Force slice 1 to be marked active. This is necessary
+        # for booting the image from a USB device to work.
+        print "a 1"
+    }
+    ' > ${NANO_OBJ}/_.fdisk
+
+    IMG=${NANO_DISKIMGDIR}/${NANO_IMGNAME}
+    BS=${NANO_SECTS}b
+
+    if [ "${NANO_MD_BACKING}" = "swap" ] ; then
+        MD=`mdconfig -a -t swap -s ${NANO_MEDIASIZE} -x ${NANO_SECTS} \
+            -y ${NANO_HEADS}`
+    else
+        echo ""; echo "Creating md backing file ${IMG} ..."
+        _c=`expr ${NANO_MEDIASIZE} / ${NANO_SECTS}`
+        pprint 2 "dd if=/dev/zero of=${IMG} bs=${BS} count=${_c}"
+        dd if=/dev/zero of=${IMG} bs=${BS} count=${_c}
+        pprint 2 "mdconfig -a -t vnode -f ${IMG} -x ${NANO_SECTS} -y ${NANO_HEADS}"
+        MD=`mdconfig -a -t vnode -f ${IMG} -x ${NANO_SECTS} \
+            -y ${NANO_HEADS}`
+    fi
+	
+	trap "mdconfig -d -u $MD" 1 2 15 EXIT
+
+    echo ""; echo "Write partition table ..."
+    FDISK=${NANO_OBJ}/_.fdisk
+    pprint 2 "fdisk -i -f ${FDISK} ${MD}"
+    fdisk -i -f ${FDISK} ${MD}
+    pprint 2 "fdisk ${MD}"
+    fdisk ${MD}
+
+    # Create first image
+    IMG1=${NANO_DISKIMGDIR}/_.disk.image1
+    echo ""; echo "Create first image ${IMG1} ..."
+    SIZE=`awk '/^p 1/ { print $5 "b" }' ${FDISK}`
+    pprint 2 "${NANO_MAKEFS} -s ${SIZE} ${IMG1} ${NANO_WORLDDIR}"
+	# TO DO: glabel patch !!!!
+    ${NANO_MAKEFS} -s ${SIZE} ${IMG1} ${NANO_WORLDDIR}
+    pprint 2 "dd if=${IMG1} of=/dev/${MD}s1 bs=${BS}"
+    dd if=${IMG1} of=/dev/${MD}s1 bs=${BS}
+	tunefs -L ${NANO_GLABEL_SYS}s1a /dev/${MD}s1
+
+	generate_mtree /dev/${MD}s1a ${MNT}
+
+    if [ $NANO_IMAGES -gt 1 -a $NANO_INIT_IMG2 -gt 0 ] ; then
+        IMG2=${NANO_DISKIMGDIR}/_.disk.image2
+        echo ""; echo "Create second image ${IMG2}..."
+        for f in ${NANO_WORLDDIR}/etc/fstab ${NANO_WORLDDIR}/conf/base/etc/fstab
+        do
+            sed -i "" "s/${NANO_DRIVE}s1/${NANO_DRIVE}s2/g" $f
+        done
+
+        SIZE=`awk '/^p 2/ { print $5 "b" }' ${FDISK}`
+        pprint 2 "${NANO_MAKEFS} -s ${SIZE} ${IMG2} ${NANO_WORLDDIR}"
+        ${NANO_MAKEFS} -s ${SIZE} ${IMG2} ${NANO_WORLDDIR}
+        pprint 2 "dd if=${IMG2} of=/dev/${MD}s2 bs=${BS}"
+        dd if=${IMG2} of=/dev/${MD}s2 bs=${BS}
+		tunefs -L ${NANO_GLABEL_SYS}s2a /dev/${MD}s1
+    fi
+
+	# Create Config slice
+    CFG=${NANO_DISKIMGDIR}/_.disk.cfg
+    echo ""; echo "Creating config partition ${CFG}..."
+    SIZE=`awk '/^p 3/ { print $5 "b" }' ${FDISK}`
+    # XXX: fill from where ?
+    pprint 2 "${NANO_MAKEFS} -s ${SIZE} ${CFG} ${NANO_CFGDIR}"
+	# NEED TO SET THE LABEL !!!!!
+    ${NANO_MAKEFS} -s ${SIZE} ${CFG} ${NANO_CFGDIR}
+    pprint 2 "dd if=${CFG} of=/dev/${MD}s3 bs=${BS}"
+    dd if=${CFG} of=/dev/${MD}s3 bs=${BS}
+	tunefs -L ${NANO_GLABEL_SYS}s3 /dev/${MD}s3
+    pprint 2 "rm ${CFG}"
+    rm ${CFG}; CFG=         # NB: disable printing below
+
+    # Create Data slice, if any.
+    if [ $NANO_DATASIZE -gt 0 ] ; then
+        DATA=${NANO_DISKIMGDIR}/_.disk.data
+        echo ""; echo "Creating data partition ${DATA}..."
+        SIZE=`awk '/^p 4/ { print $5 "b" }' ${FDISK}`
+        # XXX: fill from where ?
+        pprint 2 "${NANO_MAKEFS} -s ${SIZE} ${DATA} /var/empty"
+		# NEED TO SET THE LABEL !!!
+        ${NANO_MAKEFS} -s ${SIZE} ${DATA} /var/empty
+        pprint 2 "dd if=${DATA} of=/dev/${MD}s4 bs=${BS}"
+        dd if=${DATA} of=/dev/${MD}s4 bs=${BS}
+		tunefs -L ${NANO_GLABEL_DATA} /dev/${MD}s4
+        pprint 2 "rm ${DATA}"
+        rm ${DATA}; DATA=   # NB: disable printing below
+    fi
+
+    if [ "${NANO_MD_BACKING}" = "swap" ] ; then
+        echo "Writing out _.disk.full..."
+        dd if=/dev/${MD} of=${IMG} bs=${BS}
+    fi
+
+	echo ""
+    echo "Completed images in:"
+    echo ""
+    echo "Full disk:         ${IMG}"
+    echo "Primary partition: ${IMG1}"
+    test "${IMG2}" && echo "2ndary partition:  ${IMG2}"
+    test "${CFG}" &&  echo "/cfg partition:    ${CFG}"
+    test "${DATA}" && echo "/data partition:   ${DATA}"
+    echo ""
+    echo "Use dd if=<file> of=/dev/<somewhere> bs=${BS} to transfer an"
+    echo "image to bootable media /dev/<somewhere>."
+    ) > ${MAKEOBJDIRPREFIX}/_.di 2>&1
+}
+
+# Need to adapt NANO_LABEL variable with the old use ! 
+create_sparc64_diskimage ( ) (
+    pprint 2 "build diskimage"
+    pprint 3 "log: ${NANO_OBJ}/_.di"
+   # Using sparc bootloader
+   NANO_BOOTLOADER="boot/boot1"
+
+    (
+    IMG=${NANO_DISKIMGDIR}/${NANO_IMGNAME}
+    MNT=${NANO_OBJ}/_.mnt
+    mkdir -p ${MNT}
+
+    if [ "${NANO_MD_BACKING}" = "swap" ] ; then
+        MD=`mdconfig -a -t swap -s ${NANO_MEDIASIZE} -x ${NANO_SECTS} \
+            -y ${NANO_HEADS}`
+    else
+        echo "Creating md backing file..."
+        dd if=/dev/zero of=${IMG} bs=${NANO_SECTS}b \
+            count=`expr ${NANO_MEDIASIZE} / ${NANO_SECTS}`
+        MD=`mdconfig -a -t vnode -f ${IMG} -x ${NANO_SECTS} \
+            -y ${NANO_HEADS}`
+    fi
+
+    trap "echo 'Running exit trap code' ; df -i ${MNT} ; umount ${MNT} || true ; mdconfig -d -u $MD" 1 2 15 EXIT
+   # Create initial bootable label:
+   echo "Creating initial empty but bootable sunlabel..."
+   sunlabel -w -B ${MD} auto
+   
+   # Extracting label prototype in cylinder unit
+   sunlabel -c ${MD} > ${NANO_OBJ}/_.sunlabel
+
+   # Generate partition on the prototype file
+   # Need to calc the NANO_CODESIZE and the media size that is smaller than given (why??)
+   # Warning, from sunlabel man page  : "partitions in the Sun OpenBoot PROM
+    # must always start at a cylinder boundary (for whatever geometry emulation
+    # has been chosen)."
+   if [ ${NANO_CODESIZE} = 0 ]; then
+       #MESURED_MEDIASIZE=`grep "sectors/unit" ${NANO_OBJ}/_.sunlabel | cut -d' ' -f 2`
+   MESURED_MEDIASIZE_CYL=`grep "text" ${NANO_OBJ}/_.sunlabel| cut -d' ' -f 4`
+   SEC_PER_CYL=`grep "sectors/cylinder" ${NANO_OBJ}/_.sunlabel | cut -d' ' -f 2`
+   NANO_CONFSIZE_CYL=`expr $NANO_CONFSIZE / $SEC_PER_CYL`
+   NANO_DATASIZE_CYL=`expr $NANO_DATASIZE / $SEC_PER_CYL`
+   NANO_CODESIZE_CYL=`expr \( $MESURED_MEDIASIZE_CYL - $NANO_CONFSIZE_CYL - $NANO_DATASIZE_CYL \) / 2`
+   fi  
+   echo "a: ${NANO_CODESIZE_CYL} 0" >> ${NANO_OBJ}/_.sunlabel
+   echo "d: ${NANO_CODESIZE_CYL} *" >> ${NANO_OBJ}/_.sunlabel
+   echo "e: ${NANO_CONFSIZE_CYL} *" >> ${NANO_OBJ}/_.sunlabel
+   echo "f: ${NANO_DATASIZE_CYL} *" >> ${NANO_OBJ}/_.sunlabel
+
+   # Apply the label prototype file to the md disk
+   sunlabel -c -R ${MD} ${NANO_OBJ}/_.sunlabel
+
+	# Create first image
+    populate_slice /dev/${MD}s1a ${NANO_WORLDDIR} ${MNT} "s1a"
+
+	generate_mtree /dev/${MD}s1a ${MNT}
+
+    if [ $NANO_IMAGES -gt 1 -a $NANO_INIT_IMG2 -gt 0 ] ; then
+        # Duplicate to second image (if present)
+        echo "Duplicating to second image..."
+        dd if=/dev/${MD}a of=/dev/${MD}d bs=64k
+        mount /dev/${MD}d ${MNT}
+        for f in ${MNT}/etc/fstab ${MNT}/conf/base/etc/fstab
+        do
+            sed -i "" "s/${NANO_DRIVE}a/${NANO_DRIVE}d/g" $f
+        done
+        umount ${MNT}
+		# Override the label from the first partition so we
+        # don't confuse glabel with duplicates.
+        if [ ! -z ${NANO_LABEL} ]; then
+            tunefs -L ${NANO_LABEL}"s2a" /dev/${MD}s2a
+        fi
+
+    fi
+
+	# Create Config slice
+    populate_cfg_slice /dev/${MD}s3 "${NANO_CFGDIR}" ${MNT} "s3"
+
+    # Create Data slice, if any.
+    if [ $NANO_DATASIZE -ne 0 ] ; then
+        populate_data_slice /dev/${MD}s4 "${NANO_DATADIR}" ${MNT} "s4"
+    fi
+
+	if [ "${NANO_MD_BACKING}" = "swap" ] ; then
+        if [ ${NANO_IMAGE_MBRONLY} ]; then
+            echo "Writing out _.disk.mbr..."
+            dd if=/dev/${MD} of=${NANO_DISKIMGDIR}/_.disk.mbr bs=512 count=1
+        else
+            echo "Writing out ${NANO_IMGNAME}..."
+            dd if=/dev/${MD} of=${IMG} bs=64k
+        fi
+    fi
+
+	if [ "${NANO_MD_BACKING}" = "swap" ] ; then
+        if [ ${NANO_IMAGE_MBRONLY} ]; then
+            echo "Writing out _.disk.mbr..."
+            dd if=/dev/${MD} of=${NANO_DISKIMGDIR}/_.disk.mbr bs=512 count=1
+        else
+            echo "Writing out ${NANO_IMGNAME}..."
+            dd if=/dev/${MD} of=${IMG} bs=64k
+        fi
+    fi
+
+    if ${do_copyout_partition} ; then
+        echo "Writing out _.disk.image..."
+        dd if=/dev/${MD}s1 of=${NANO_DISKIMGDIR}/_.disk.image bs=64k
+    fi
+    mdconfig -d -u $MD
+
+    trap - 1 2 15 EXIT
+	trap "nano_cleanup" EXIT
+
+    ) > ${NANO_OBJ}/_.di 2>&1
+)
+
 last_orders () (
 	# Redefine this function with any last orders you may have
 	# after the build completed, for instance to copy the finished
@@ -628,7 +1005,7 @@
 
 cust_install_files () (
 	cd ${NANO_TOOLS}/Files
-	find . -print | grep -Ev '/(CVS|\.svn)' | cpio -dumpv ${NANO_WORLDDIR}
+	find . -print | grep -Ev '/(CVS|\.svn)' | cpio -Ldumpv ${NANO_WORLDDIR}
 )
 
 #######################################################################
@@ -636,12 +1013,18 @@
 
 cust_pkg () (
 
+	# If the package directory doesn't exist, we're done.
+	if [ ! -d ${NANO_PACKAGE_DIR} ]; then
+		echo "DONE 0 packages"
+		return 0
+	fi
+
 	# Copy packages into chroot
 	mkdir -p ${NANO_WORLDDIR}/Pkg
 	(
 		cd ${NANO_PACKAGE_DIR}
 		find ${NANO_PACKAGE_LIST} -print |
-		    cpio -dumpv ${NANO_WORLDDIR}/Pkg
+		    cpio -Ldumpv ${NANO_WORLDDIR}/Pkg
 	)
 
 	# Count & report how many we have to install
@@ -712,12 +1095,13 @@
 
 usage () {
 	(
-	echo "Usage: $0 [-biknqvw] [-c config_file]"
+	echo "Usage: $0 [-bfiknqvw] [-c config_file]"
 	echo "	-b	suppress builds (both kernel and world)"
+	echo "	-f	suppress code slice extraction"
 	echo "	-i	suppress disk image build"
 	echo "	-k	suppress buildkernel"
 	echo "	-n	add -DNO_CLEAN to buildworld, buildkernel, etc"
-	echo "	-q	make output more quiet"
+	echo "	-q	make output quieter"
 	echo "	-v	make output more verbose"
 	echo "	-w	suppress buildworld"
 	echo "	-c	specify config file"
@@ -732,9 +1116,10 @@
 do_kernel=true
 do_world=true
 do_image=true
+do_copyout_partition=true
 
 set +e
-args=`getopt bc:hiknqvw $*`
+args=`getopt bc:fhiknqvw $*`
 if [ $? -ne 0 ] ; then
 	usage
 	exit 2
@@ -760,6 +1145,10 @@
 		shift
 		shift
 		;;
+	-f)
+		do_copyout_partition=false
+		shift
+		;;
 	-h)
 		usage
 		;;
@@ -793,6 +1182,7 @@
 	echo "$0: Extraneous arguments supplied"
 	usage
 fi
+trap "nano_cleanup" EXIT
 
 #######################################################################
 # Setup and Export Internal variables
@@ -820,6 +1210,11 @@
 	NANO_PMAKE="${NANO_PMAKE} -DNO_CLEAN"
 fi
 
+# Override user's NANO_DRIVE if they specified a NANO_LABEL
+if [ ! -z "${NANO_LABEL}" ]; then
+	NANO_DRIVE=ufs/${NANO_LABEL}
+fi
+
 export MAKEOBJDIRPREFIX
 
 export NANO_ARCH
@@ -844,6 +1239,7 @@
 export NANO_WORLDDIR
 export NANO_BOOT0CFG
 export NANO_BOOTLOADER
+export NANO_LABEL
 
 #######################################################################
 # And then it is as simple as that...
@@ -867,6 +1263,9 @@
 fi
 
 if $do_kernel ; then
+	if ! $do_world ; then
+		make_conf_build
+	fi
 	build_kernel
 else
 	pprint 2 "Skipping buildkernel (as instructed)"
