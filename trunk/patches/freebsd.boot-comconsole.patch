diff --git sys/boot/common/bootstrap.h.orig sys/boot/common/bootstrap.h
index f6eab3d..516b8a5 100644
--- sys/boot/common/bootstrap.h.orig
+++ sys/boot/common/bootstrap.h
@@ -109,10 +109,10 @@ struct console
     const char	*c_name;
     const char	*c_desc;
     int		c_flags;
-#define C_PRESENTIN	(1<<0)
-#define C_PRESENTOUT	(1<<1)
-#define C_ACTIVEIN	(1<<2)
-#define C_ACTIVEOUT	(1<<3)
+#define C_PRESENTIN	(1<<0)	    /* console can provide input */
+#define C_PRESENTOUT	(1<<1)	    /* console can provide output */
+#define C_ACTIVEIN	(1<<2)	    /* user wants input from console */
+#define C_ACTIVEOUT	(1<<3)	    /* user wants output to console */
     void	(* c_probe)(struct console *cp);	/* set c_flags to match hardware */
     int		(* c_init)(int arg);			/* reinit XXX may need more args */
     void	(* c_out)(int c);			/* emit c */
diff --git a/sys/boot/common/console.c b/sys/boot/common/console.c
index d140a96..6c1fdab 100644
--- sys/boot/common/console.c.orig
+++ sys/boot/common/console.c
@@ -100,11 +100,12 @@ getchar(void)
 {
     int		cons;
     int		rv;
-    
+
     /* Loop forever polling all active consoles */
     for(;;)
 	for (cons = 0; consoles[cons] != NULL; cons++)
-	    if ((consoles[cons]->c_flags & C_ACTIVEIN) && 
+	    if ((consoles[cons]->c_flags & (C_PRESENTIN | C_ACTIVEIN)) ==
+		(C_PRESENTIN | C_ACTIVEIN) &&
 		((rv = consoles[cons]->c_in()) != -1))
 		return(rv);
 }
@@ -115,7 +116,8 @@ ischar(void)
     int		cons;
 
     for (cons = 0; consoles[cons] != NULL; cons++)
-	if ((consoles[cons]->c_flags & C_ACTIVEIN) && 
+	if ((consoles[cons]->c_flags & (C_PRESENTIN | C_ACTIVEIN)) ==
+	    (C_PRESENTIN | C_ACTIVEIN) &&
 	    (consoles[cons]->c_ready() != 0))
 		return(1);
     return(0);
@@ -125,13 +127,14 @@ void
 putchar(int c)
 {
     int		cons;
-    
+
     /* Expand newlines */
     if (c == '\n')
 	putchar('\r');
-    
+
     for (cons = 0; consoles[cons] != NULL; cons++)
-	if (consoles[cons]->c_flags & C_ACTIVEOUT)
+	if ((consoles[cons]->c_flags & (C_PRESENTOUT | C_ACTIVEOUT)) ==
+	    (C_PRESENTOUT | C_ACTIVEOUT))
 	    consoles[cons]->c_out(c);
 }
 
@@ -220,6 +223,10 @@ cons_change(const char *string)
 	if (cons >= 0) {
 	    consoles[cons]->c_flags |= C_ACTIVEIN | C_ACTIVEOUT;
 	    consoles[cons]->c_init(0);
+	    if ((consoles[cons]->c_flags & (C_PRESENTIN | C_PRESENTOUT)) !=
+		(C_PRESENTIN | C_PRESENTOUT))
+		printf("console %s failed to initialize\n",
+		    consoles[cons]->c_name);
 	}
     }
 
diff --git sys/boot/i386/libi386/comconsole.c.orig sys/boot/i386/libi386/comconsole.c
index bf0d67b..3822597 100644
--- sys/boot/i386/libi386/comconsole.c.orig
+++ sys/boot/i386/libi386/comconsole.c
@@ -63,7 +63,6 @@ static void	comc_setup(int speed, int port);
 static int	comc_speed_set(struct env_var *ev, int flags,
 		    const void *value);
 
-static int	comc_started;
 static int	comc_curspeed;
 static int	comc_port = COMPORT;
 static uint32_t	comc_locator;
@@ -87,9 +86,6 @@ comc_probe(struct console *cp)
     int speed, port;
     uint32_t locator;
 
-    /* XXX check the BIOS equipment list? */
-    cp->c_flags |= (C_PRESENTIN | C_PRESENTOUT);
-
     if (comc_curspeed == 0) {
 	comc_curspeed = COMSPEED;
 	/*
@@ -137,18 +133,19 @@ comc_probe(struct console *cp)
 	env_setenv("comconsole_pcidev", EV_VOLATILE, env, comc_pcidev_set,
 	    env_nounset);
     }
+    comc_setup(comc_curspeed, comc_port);
 }
 
 static int
 comc_init(int arg)
 {
-    if (comc_started && arg == 0)
-	return 0;
-    comc_started = 1;
 
     comc_setup(comc_curspeed, comc_port);
 
-    return(0);
+    if ((comconsole.c_flags & (C_PRESENTIN | C_PRESENTOUT)) ==
+	(C_PRESENTIN | C_PRESENTOUT))
+	return (CMD_OK);
+    return (CMD_ERROR);
 }
 
 static void
@@ -166,13 +163,13 @@ comc_putchar(int c)
 static int
 comc_getchar(void)
 {
-    return(comc_ischar() ? inb(comc_port + com_data) : -1);
+    return (comc_ischar() ? inb(comc_port + com_data) : -1);
 }
 
 static int
 comc_ischar(void)
 {
-    return(inb(comc_port + com_lsr) & LSR_RXRDY);
+    return (inb(comc_port + com_lsr) & LSR_RXRDY);
 }
 
 static int
@@ -185,7 +182,8 @@ comc_speed_set(struct env_var *ev, int flags, const void *value)
 	return (CMD_ERROR);
     }
 
-    if (comc_started && comc_curspeed != speed)
+    if ((comconsole.c_flags & (C_ACTIVEIN | C_ACTIVEOUT)) != 0 &&
+	comc_curspeed != speed)
 	comc_setup(speed, comc_port);
 
     env_setenv(ev->ev_name, flags | EV_NOHOOK, value, NULL, NULL);
@@ -203,7 +201,8 @@ comc_port_set(struct env_var *ev, int flags, const void *value)
 	return (CMD_ERROR);
     }
 
-    if (comc_started && comc_port != port) {
+    if ((comconsole.c_flags & (C_ACTIVEIN | C_ACTIVEOUT)) != 0 &&
+	comc_port != port) {
 	comc_setup(comc_curspeed, port);
 	set_hw_console_hint();
     }
@@ -305,7 +304,8 @@ comc_pcidev_set(struct env_var *ev, int flags, const void *value)
 		printf("Invalid pcidev\n");
 		return (CMD_ERROR);
 	}
-	if (comc_started && comc_locator != locator) {
+	if ((comconsole.c_flags & (C_ACTIVEIN | C_ACTIVEOUT)) != 0 &&
+	    comc_locator != locator) {
 		error = comc_pcidev_handle(locator);
 		if (error != CMD_OK)
 			return (error);
@@ -317,6 +317,8 @@ comc_pcidev_set(struct env_var *ev, int flags, const void *value)
 static void
 comc_setup(int speed, int port)
 {
+    static int TRY_COUNT = 1000000;
+    int tries;
 
     comc_curspeed = speed;
     comc_port = port;
@@ -327,9 +329,15 @@ comc_setup(int speed, int port)
     outb(comc_port + com_cfcr, COMC_FMT);
     outb(comc_port + com_mcr, MCR_RTS | MCR_DTR);
 
+    tries = 0;
     do
         inb(comc_port + com_data);
-    while (inb(comc_port + com_lsr) & LSR_RXRDY);
+    while (inb(comc_port + com_lsr) & LSR_RXRDY && ++tries < TRY_COUNT);
+
+    if (tries < TRY_COUNT)
+	comconsole.c_flags |= (C_PRESENTIN | C_PRESENTOUT);
+    else
+	comconsole.c_flags &= ~(C_PRESENTIN | C_PRESENTOUT);
 }
 
 static int

diff --git sys/boot/i386/boot2/boot2.c.orig sys/boot/i386/boot2/boot2.c
index fbafc5f..6998026 100644
--- sys/boot/i386/boot2/boot2.c.orig
+++ sys/boot/i386/boot2/boot2.c
@@ -415,8 +415,10 @@ parse()
 	    }
 	    ioctrl = OPT_CHECK(RBX_DUAL) ? (IO_SERIAL|IO_KEYBOARD) :
 		     OPT_CHECK(RBX_SERIAL) ? IO_SERIAL : IO_KEYBOARD;
-	    if (ioctrl & IO_SERIAL)
-	        sio_init(115200 / comspeed);
+	    if (ioctrl & IO_SERIAL) {
+	        if (sio_init(115200 / comspeed) != 0)
+		    ioctrl &= ~IO_SERIAL;
+	    }
 	} else {
 	    for (q = arg--; *q && *q != '('; q++);
 	    if (*q) {
diff --git sys/boot/i386/boot2/lib.h.orig sys/boot/i386/boot2/lib.h
index 3ae2b9d80..d8d3317 100644
--- sys/boot/i386/boot2/lib.h.orig
+++ sys/boot/i386/boot2/lib.h
@@ -17,8 +17,8 @@
  * $FreeBSD$
  */
 
-void sio_init(int) __attribute__((regparm (3)));
-void sio_flush(void);
+int sio_init(int) __attribute__((regparm (3)));
+int sio_flush(void);
 void sio_putc(int) __attribute__((regparm (3)));
 int sio_getc(void);
 int sio_ischar(void);
diff --git sys/boot/i386/boot2/sio.S.orig sys/boot/i386/boot2/sio.S
index bbebb59..f2cd5c7 100644
--- sys/boot/i386/boot2/sio.S.orig
+++ sys/boot/i386/boot2/sio.S
@@ -24,7 +24,7 @@
 		.globl sio_getc
 		.globl sio_ischar
 
-/* void sio_init(int div) */
+/* int sio_init(int div) */
 
 sio_init:	pushl %eax
 		movw $SIO_PRT+0x3,%dx		# Data format reg
@@ -43,12 +43,16 @@ sio_init:	pushl %eax
 		call sio_flush
 		ret
 
-/* void sio_flush(void) */
+/* int sio_flush(void) */
 
-sio_flush.0:	call sio_getc.1 		# Get character
-sio_flush:	call sio_ischar 		# Check for character
-		jnz sio_flush.0 		# Till none
-		ret				# To caller
+sio_flush:	xorl %eax,%eax			# Return value
+		xorl %ecx,%ecx			# Timeout
+		movb $0x80,%ch			#  counter
+sio_flush.1:	call sio_ischar 		# Check for character
+		jz sio_flush.2			# Till none
+		loop sio_flush.1		#  or counter is zero
+		movb $1, %al			# Exhausted all tries
+sio_flush.2:	ret				# To caller
 
 /* void sio_putc(int c) */
 
diff --git sys/boot/i386/btx/btx/btx.S.orig sys/boot/i386/btx/btx/btx.S
index bf4400e..c41457f 100644
--- sys/boot/i386/btx/btx/btx.S.orig
+++ sys/boot/i386/btx/btx/btx.S
@@ -812,7 +812,7 @@ putstr: 	lodsb				# Load char
 		.set SIO_DIV,(115200/SIOSPD)	# 115200 / SPD
 
 /*
- * void sio_init(void)
+ * int sio_init(void)
  */
 sio_init:	movw $SIO_PRT+0x3,%dx		# Data format reg
 		movb $SIO_FMT|0x80,%al		# Set format
@@ -828,14 +828,19 @@ sio_init:	movw $SIO_PRT+0x3,%dx		# Data format reg
 		movb $0x3,%al			# Set RTS,
 		outb %al,(%dx)			#  DTR
 		incl %edx			# Line status reg
+		call sio_getc.1 		# Get character
 
 /*
- * void sio_flush(void)
+ * int sio_flush(void)
  */
-sio_flush.0:	call sio_getc.1 		# Get character
-sio_flush:	call sio_ischar 		# Check for character
-		jnz sio_flush.0 		# Till none
-		ret				# To caller
+sio_flush:	xorl %eax,%eax			# Return value
+		xorl %ecx,%ecx			# Timeout
+		movb $0x80,%ch			#  counter
+sio_flush.1:	call sio_ischar 		# Check for character
+		jz sio_flush.2			# Till none
+		loop sio_flush.1		#  or counter is zero
+		movb $1, %al			# Exhausted all tries
+sio_flush.2:	ret				# To caller
 
 /*
  * void sio_putc(int c)
diff --git sys/boot/i386/gptboot/gptboot.c.orig sys/boot/i386/gptboot/gptboot.c
index b976378..0596499 100644
--- sys/boot/i386/gptboot/gptboot.c.orig
+++ sys/boot/i386/gptboot/gptboot.c
@@ -379,8 +379,10 @@ parse(char *cmdstr, int *dskupdated)
 	    }
 	    ioctrl = OPT_CHECK(RBX_DUAL) ? (IO_SERIAL|IO_KEYBOARD) :
 		     OPT_CHECK(RBX_SERIAL) ? IO_SERIAL : IO_KEYBOARD;
-	    if (ioctrl & IO_SERIAL)
-	        sio_init(115200 / comspeed);
+	    if (ioctrl & IO_SERIAL) {
+	        if (sio_init(115200 / comspeed) != 0)
+		    ioctrl &= ~IO_SERIAL;
+	    }
 	} else {
 	    for (q = arg--; *q && *q != '('; q++);
 	    if (*q) {
diff --git sys/boot/i386/zfsboot/zfsboot.c.orig sys/boot/i386/zfsboot/zfsboot.c
index e304e01..cd0233e 100644
--- sys/boot/i386/zfsboot/zfsboot.c.orig
+++ sys/boot/i386/zfsboot/zfsboot.c
@@ -908,8 +908,10 @@ parse(void)
 	    }
 	    ioctrl = OPT_CHECK(RBX_DUAL) ? (IO_SERIAL|IO_KEYBOARD) :
 		     OPT_CHECK(RBX_SERIAL) ? IO_SERIAL : IO_KEYBOARD;
-	    if (ioctrl & IO_SERIAL)
-	        sio_init(115200 / comspeed);
+	    if (ioctrl & IO_SERIAL) {
+	        if (sio_init(115200 / comspeed) != 0)
+		    ioctrl &= ~IO_SERIAL;
+	    }
 	} if (c == '?') {
 	    dnode_phys_t dn;
 
