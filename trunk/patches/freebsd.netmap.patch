Index: sys/dev/re/if_re.c
===================================================================
--- sys/dev/re/if_re.c	(revision 243710)
+++ sys/dev/re/if_re.c	(working copy)
@@ -1753,8 +1753,12 @@
 		bus_teardown_intr(dev, sc->rl_irq[0], sc->rl_intrhand[0]);
 		sc->rl_intrhand[0] = NULL;
 	}
-	if (ifp != NULL)
+	if (ifp != NULL) {
+#ifdef DEV_NETMAP
+		netmap_detach(ifp);
+#endif /* DEV_NETMAP */
 		if_free(ifp);
+	}
 	if ((sc->rl_flags & (RL_FLAG_MSI | RL_FLAG_MSIX)) == 0)
 		rid = 0;
 	else
@@ -1843,9 +1847,6 @@
 		bus_dma_tag_destroy(sc->rl_ldata.rl_stag);
 	}
 
-#ifdef DEV_NETMAP
-	netmap_detach(ifp);
-#endif /* DEV_NETMAP */
 	if (sc->rl_parent_tag)
 		bus_dma_tag_destroy(sc->rl_parent_tag);
 
@@ -2111,8 +2112,8 @@
 	ifp = sc->rl_ifp;
 #ifdef DEV_NETMAP
 	if (ifp->if_capenable & IFCAP_NETMAP) {
-		NA(ifp)->rx_rings->nr_kflags |= NKR_PENDINTR;
-		selwakeuppri(&NA(ifp)->rx_rings->si, PI_NET);
+		NA(ifp)->rx_rings[0].nr_kflags |= NKR_PENDINTR;
+		selwakeuppri(&NA(ifp)->rx_rings[0].si, PI_NET);
 		return 0;
 	}
 #endif /* DEV_NETMAP */
diff -ruN sys/dev/netmap.orig/if_em_netmap.h sys/dev/netmap/if_em_netmap.h
--- sys/dev/netmap.orig/if_em_netmap.h	2013-01-09 01:04:19.000000000 +0100
+++ sys/dev/netmap/if_em_netmap.h	2013-01-09 01:05:09.000000000 +0100
@@ -24,7 +24,7 @@
  */
 
 /*
- * $FreeBSD: releng/9.1/sys/dev/netmap/if_em_netmap.h 235549 2012-05-17 15:02:51Z luigi $
+ * $FreeBSD: head/sys/dev/netmap/if_em_netmap.h 238985 2012-08-02 11:59:43Z luigi $
  * $Id: if_em_netmap.h 10627 2012-02-23 19:37:15Z luigi $
  *
  * netmap support for em.
@@ -171,7 +171,7 @@
 	u_int j, k, l, n = 0, lim = kring->nkr_num_slots - 1;
 
 	/* generate an interrupt approximately every half ring */
-	int report_frequency = kring->nkr_num_slots >> 1;
+	u_int report_frequency = kring->nkr_num_slots >> 1;
 
 	k = ring->cur;
 	if (k > lim)
diff -ruN sys/dev/netmap.orig/if_igb_netmap.h sys/dev/netmap/if_igb_netmap.h
--- sys/dev/netmap.orig/if_igb_netmap.h	2013-01-09 01:04:19.000000000 +0100
+++ sys/dev/netmap/if_igb_netmap.h	2013-01-09 01:05:09.000000000 +0100
@@ -24,7 +24,7 @@
  */
 
 /*
- * $FreeBSD: releng/9.1/sys/dev/netmap/if_igb_netmap.h 235549 2012-05-17 15:02:51Z luigi $
+ * $FreeBSD: head/sys/dev/netmap/if_igb_netmap.h 238985 2012-08-02 11:59:43Z luigi $
  * $Id: if_igb_netmap.h 10627 2012-02-23 19:37:15Z luigi $
  *
  * Netmap support for igb, partly contributed by Ahmed Kooli
@@ -125,7 +125,7 @@
 	u_int j, k, l, n = 0, lim = kring->nkr_num_slots - 1;
 
 	/* generate an interrupt approximately every half ring */
-	int report_frequency = kring->nkr_num_slots >> 1;
+	u_int report_frequency = kring->nkr_num_slots >> 1;
 
 	k = ring->cur;
 	if (k > lim)
diff -ruN sys/dev/netmap.orig/if_lem_netmap.h sys/dev/netmap/if_lem_netmap.h
--- sys/dev/netmap.orig/if_lem_netmap.h	2013-01-09 01:04:19.000000000 +0100
+++ sys/dev/netmap/if_lem_netmap.h	2013-01-09 01:05:09.000000000 +0100
@@ -25,7 +25,7 @@
 
 
 /*
- * $FreeBSD: releng/9.1/sys/dev/netmap/if_lem_netmap.h 235549 2012-05-17 15:02:51Z luigi $
+ * $FreeBSD: head/sys/dev/netmap/if_lem_netmap.h 232238 2012-02-27 19:05:01Z luigi $
  * $Id: if_lem_netmap.h 10627 2012-02-23 19:37:15Z luigi $
  *
  * netmap support for "lem"
diff -ruN sys/dev/netmap.orig/if_re_netmap.h sys/dev/netmap/if_re_netmap.h
--- sys/dev/netmap.orig/if_re_netmap.h	2013-01-09 01:04:19.000000000 +0100
+++ sys/dev/netmap/if_re_netmap.h	2013-01-09 01:05:09.000000000 +0100
@@ -24,7 +24,7 @@
  */
 
 /*
- * $FreeBSD: releng/9.1/sys/dev/netmap/if_re_netmap.h 235549 2012-05-17 15:02:51Z luigi $
+ * $FreeBSD: head/sys/dev/netmap/if_re_netmap.h 234225 2012-04-13 15:33:12Z luigi $
  * $Id: if_re_netmap.h 10609 2012-02-22 19:44:58Z luigi $
  *
  * netmap support for "re"
diff -ruN sys/dev/netmap.orig/ixgbe_netmap.h sys/dev/netmap/ixgbe_netmap.h
--- sys/dev/netmap.orig/ixgbe_netmap.h	2013-01-09 01:04:19.000000000 +0100
+++ sys/dev/netmap/ixgbe_netmap.h	2013-01-09 01:05:09.000000000 +0100
@@ -24,7 +24,7 @@
  */
 
 /*
- * $FreeBSD: releng/9.1/sys/dev/netmap/ixgbe_netmap.h 235549 2012-05-17 15:02:51Z luigi $
+ * $FreeBSD: head/sys/dev/netmap/ixgbe_netmap.h 244514 2012-12-20 22:26:03Z luigi $
  * $Id: ixgbe_netmap.h 10627 2012-02-23 19:37:15Z luigi $
  *
  * netmap modifications for ixgbe
@@ -198,14 +198,17 @@
  * Reconcile kernel and user view of the transmit ring.
  * This routine might be called frequently so it must be efficient.
  *
- * Userspace has filled tx slots up to ring->cur (excluded).
- * The last unused slot previously known to the kernel was kring->nkr_hwcur,
- * and the last interrupt reported kring->nr_hwavail slots available.
+ * ring->cur holds the userspace view of the current ring index.  Userspace
+ * has filled the tx slots from the previous call's ring->cur up to but not
+ * including ring->cur for this call.  In this function the kernel updates
+ * kring->nr_hwcur to ring->cur, thus slots [kring->nr_hwcur, ring->cur) are
+ * now ready to transmit.  At the last interrupt kring->nr_hwavail slots were
+ * available.
  *
  * This function runs under lock (acquired from the caller or internally).
  * It must first update ring->avail to what the kernel knows,
- * subtract the newly used slots (ring->cur - kring->nkr_hwcur)
- * from both avail and nr_hwavail, and set ring->nkr_hwcur = ring->cur
+ * subtract the newly used slots (ring->cur - kring->nr_hwcur)
+ * from both avail and nr_hwavail, and set ring->nr_hwcur = ring->cur
  * issuing a dmamap_sync on all slots.
  *
  * Since ring comes from userspace, its content must be read only once,
@@ -233,7 +236,7 @@
 	 * seems very expensive, so we interrupt once every half ring,
 	 * or when requested with NS_REPORT
 	 */
-	int report_frequency = kring->nkr_num_slots >> 1;
+	u_int report_frequency = kring->nkr_num_slots >> 1;
 
 	if (k > lim)
 		return netmap_ring_reinit(kring);
diff -ruN sys/dev/netmap.orig/netmap.c sys/dev/netmap/netmap.c
--- sys/dev/netmap.orig/netmap.c	2013-01-09 01:04:19.000000000 +0100
+++ sys/dev/netmap/netmap.c	2013-01-09 01:05:09.000000000 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011 Matteo Landi, Luigi Rizzo. All rights reserved.
+ * Copyright (C) 2011-2012 Matteo Landi, Luigi Rizzo. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
@@ -23,6 +23,8 @@
  * SUCH DAMAGE.
  */
 
+#define NM_BRIDGE
+
 /*
  * This module supports memory mapped access to network devices,
  * see netmap(4).
@@ -52,8 +54,18 @@
  *    transmit or receive queues (or all queues for a given interface).
  */
 
+#ifdef linux
+#include "bsd_glue.h"
+static netdev_tx_t linux_netmap_start(struct sk_buff *skb, struct net_device *dev);
+#endif /* linux */
+
+#ifdef __APPLE__
+#include "osx_glue.h"
+#endif /* __APPLE__ */
+
+#ifdef __FreeBSD__
 #include <sys/cdefs.h> /* prerequisite */
-__FBSDID("$FreeBSD: releng/9.1/sys/dev/netmap/netmap.c 235549 2012-05-17 15:02:51Z luigi $");
+__FBSDID("$FreeBSD: head/sys/dev/netmap/netmap.c 241723 2012-10-19 09:41:45Z glebius $");
 
 #include <sys/types.h>
 #include <sys/module.h>
@@ -78,21 +90,16 @@
 #include <net/if.h>
 #include <net/bpf.h>		/* BIOCIMMEDIATE */
 #include <net/vnet.h>
-#include <net/netmap.h>
-#include <dev/netmap/netmap_kern.h>
 #include <machine/bus.h>	/* bus_dmamap_* */
 
 MALLOC_DEFINE(M_NETMAP, "netmap", "Network memory map");
+#endif /* __FreeBSD__ */
 
-/*
- * lock and unlock for the netmap memory allocator
- */
-#define NMA_LOCK()	mtx_lock(&nm_mem->nm_mtx);
-#define NMA_UNLOCK()	mtx_unlock(&nm_mem->nm_mtx);
-struct netmap_mem_d;
-static struct netmap_mem_d *nm_mem;	/* Our memory allocator. */
+#include <net/netmap.h>
+#include <dev/netmap/netmap_kern.h>
 
 u_int netmap_total_buffers;
+u_int netmap_buf_size;
 char *netmap_buffer_base;	/* address of an invalid buffer */
 
 /* user-controlled variables */
@@ -105,16 +112,168 @@
     CTLFLAG_RW, &netmap_verbose, 0, "Verbose mode");
 SYSCTL_INT(_dev_netmap, OID_AUTO, no_timestamp,
     CTLFLAG_RW, &netmap_no_timestamp, 0, "no_timestamp");
-int netmap_buf_size = 2048;
-TUNABLE_INT("hw.netmap.buf_size", &netmap_buf_size);
-SYSCTL_INT(_dev_netmap, OID_AUTO, buf_size,
-    CTLFLAG_RD, &netmap_buf_size, 0, "Size of packet buffers");
 int netmap_mitigate = 1;
 SYSCTL_INT(_dev_netmap, OID_AUTO, mitigate, CTLFLAG_RW, &netmap_mitigate, 0, "");
 int netmap_no_pendintr = 1;
 SYSCTL_INT(_dev_netmap, OID_AUTO, no_pendintr,
     CTLFLAG_RW, &netmap_no_pendintr, 0, "Always look for new received packets.");
 
+int netmap_drop = 0;	/* debugging */
+int netmap_flags = 0;	/* debug flags */
+int netmap_copy = 0;	/* debugging, copy content */
+
+SYSCTL_INT(_dev_netmap, OID_AUTO, drop, CTLFLAG_RW, &netmap_drop, 0 , "");
+SYSCTL_INT(_dev_netmap, OID_AUTO, flags, CTLFLAG_RW, &netmap_flags, 0 , "");
+SYSCTL_INT(_dev_netmap, OID_AUTO, copy, CTLFLAG_RW, &netmap_copy, 0 , "");
+
+#ifdef NM_BRIDGE /* support for netmap bridge */
+
+/*
+ * system parameters.
+ *
+ * All switched ports have prefix NM_NAME.
+ * The switch has a max of NM_BDG_MAXPORTS ports (often stored in a bitmap,
+ * so a practical upper bound is 64).
+ * Each tx ring is read-write, whereas rx rings are readonly (XXX not done yet).
+ * The virtual interfaces use per-queue lock instead of core lock.
+ * In the tx loop, we aggregate traffic in batches to make all operations
+ * faster. The batch size is NM_BDG_BATCH
+ */
+#define	NM_NAME			"vale"	/* prefix for the interface */
+#define NM_BDG_MAXPORTS		16	/* up to 64 ? */
+#define NM_BRIDGE_RINGSIZE	1024	/* in the device */
+#define NM_BDG_HASH		1024	/* forwarding table entries */
+#define NM_BDG_BATCH		1024	/* entries in the forwarding buffer */
+#define	NM_BRIDGES		4	/* number of bridges */
+int netmap_bridge = NM_BDG_BATCH; /* bridge batch size */
+SYSCTL_INT(_dev_netmap, OID_AUTO, bridge, CTLFLAG_RW, &netmap_bridge, 0 , "");
+
+#ifdef linux
+#define	ADD_BDG_REF(ifp)	(NA(ifp)->if_refcount++)
+#define	DROP_BDG_REF(ifp)	(NA(ifp)->if_refcount-- <= 1)
+#else /* !linux */
+#define	ADD_BDG_REF(ifp)	(ifp)->if_refcount++
+#define	DROP_BDG_REF(ifp)	refcount_release(&(ifp)->if_refcount)
+#ifdef __FreeBSD__
+#include <sys/endian.h>
+#include <sys/refcount.h>
+#endif /* __FreeBSD__ */
+#define prefetch(x)	__builtin_prefetch(x)
+#endif /* !linux */
+
+static void bdg_netmap_attach(struct ifnet *ifp);
+static int bdg_netmap_reg(struct ifnet *ifp, int onoff);
+/* per-tx-queue entry */
+struct nm_bdg_fwd {	/* forwarding entry for a bridge */
+	void *buf;
+	uint64_t dst;	/* dst mask */
+	uint32_t src;	/* src index ? */
+	uint16_t len;	/* src len */
+};
+
+struct nm_hash_ent {
+	uint64_t	mac;	/* the top 2 bytes are the epoch */
+	uint64_t	ports;
+};
+
+/*
+ * Interfaces for a bridge are all in ports[].
+ * The array has fixed size, an empty entry does not terminate
+ * the search.
+ */
+struct nm_bridge {
+	struct ifnet *bdg_ports[NM_BDG_MAXPORTS];
+	int n_ports;
+	uint64_t act_ports;
+	int freelist;	/* first buffer index */
+	NM_SELINFO_T si;	/* poll/select wait queue */
+	NM_LOCK_T bdg_lock;	/* protect the selinfo ? */
+
+	/* the forwarding table, MAC+ports */
+	struct nm_hash_ent ht[NM_BDG_HASH];
+
+	int namelen;	/* 0 means free */
+	char basename[IFNAMSIZ];
+};
+
+struct nm_bridge nm_bridges[NM_BRIDGES];
+
+#define BDG_LOCK(b)	mtx_lock(&(b)->bdg_lock)
+#define BDG_UNLOCK(b)	mtx_unlock(&(b)->bdg_lock)
+
+/*
+ * NA(ifp)->bdg_port	port index
+ */
+
+// XXX only for multiples of 64 bytes, non overlapped.
+static inline void
+pkt_copy(void *_src, void *_dst, int l)
+{
+        uint64_t *src = _src;
+        uint64_t *dst = _dst;
+        if (unlikely(l >= 1024)) {
+                bcopy(src, dst, l);
+                return;
+        }
+        for (; likely(l > 0); l-=64) {
+                *dst++ = *src++;
+                *dst++ = *src++;
+                *dst++ = *src++;
+                *dst++ = *src++;
+                *dst++ = *src++;
+                *dst++ = *src++;
+                *dst++ = *src++;
+                *dst++ = *src++;
+        }
+}
+
+/*
+ * locate a bridge among the existing ones.
+ * a ':' in the name terminates the bridge name. Otherwise, just NM_NAME.
+ * We assume that this is called with a name of at least NM_NAME chars.
+ */
+static struct nm_bridge *
+nm_find_bridge(const char *name)
+{
+	int i, l, namelen, e;
+	struct nm_bridge *b = NULL;
+
+	namelen = strlen(NM_NAME);	/* base length */
+	l = strlen(name);		/* actual length */
+	for (i = namelen + 1; i < l; i++) {
+		if (name[i] == ':') {
+			namelen = i;
+			break;
+		}
+	}
+	if (namelen >= IFNAMSIZ)
+		namelen = IFNAMSIZ;
+	ND("--- prefix is '%.*s' ---", namelen, name);
+
+	/* use the first entry for locking */
+	BDG_LOCK(nm_bridges); // XXX do better
+	for (e = -1, i = 1; i < NM_BRIDGES; i++) {
+		b = nm_bridges + i;
+		if (b->namelen == 0)
+			e = i;	/* record empty slot */
+		else if (strncmp(name, b->basename, namelen) == 0) {
+			ND("found '%.*s' at %d", namelen, name, i);
+			break;
+		}
+	}
+	if (i == NM_BRIDGES) { /* all full */
+		if (e == -1) { /* no empty slot */
+			b = NULL;
+		} else {
+			b = nm_bridges + e;
+			strncpy(b->basename, name, namelen);
+			b->namelen = namelen;
+		}
+	}
+	BDG_UNLOCK(nm_bridges);
+	return b;
+}
+#endif /* NM_BRIDGE */
 
 /*------------- memory allocator -----------------*/
 #ifdef NETMAP_MEM2
@@ -124,23 +283,62 @@
 #endif /* !NETMAP_MEM2 */
 /*------------ end of memory allocator ----------*/
 
-/* Structure associated to each thread which registered an interface. */
+
+/* Structure associated to each thread which registered an interface.
+ *
+ * The first 4 fields of this structure are written by NIOCREGIF and
+ * read by poll() and NIOC?XSYNC.
+ * There is low contention among writers (actually, a correct user program
+ * should have no contention among writers) and among writers and readers,
+ * so we use a single global lock to protect the structure initialization.
+ * Since initialization involves the allocation of memory, we reuse the memory
+ * allocator lock.
+ * Read access to the structure is lock free. Readers must check that
+ * np_nifp is not NULL before using the other fields.
+ * If np_nifp is NULL initialization has not been performed, so they should
+ * return an error to userlevel.
+ *
+ * The ref_done field is used to regulate access to the refcount in the
+ * memory allocator. The refcount must be incremented at most once for
+ * each open("/dev/netmap"). The increment is performed by the first
+ * function that calls netmap_get_memory() (currently called by
+ * mmap(), NIOCGINFO and NIOCREGIF).
+ * If the refcount is incremented, it is then decremented when the
+ * private structure is destroyed.
+ */
 struct netmap_priv_d {
-	struct netmap_if *np_nifp;	/* netmap interface descriptor. */
+	struct netmap_if * volatile np_nifp;	/* netmap interface descriptor. */
 
 	struct ifnet	*np_ifp;	/* device for which we hold a reference */
 	int		np_ringid;	/* from the ioctl */
 	u_int		np_qfirst, np_qlast;	/* range of rings to scan */
 	uint16_t	np_txpoll;
+
+	unsigned long	ref_done;	/* use with NMA_LOCK held */
 };
 
 
+static int
+netmap_get_memory(struct netmap_priv_d* p)
+{
+	int error = 0;
+	NMA_LOCK();
+	if (!p->ref_done) {
+		error = netmap_memory_finalize();
+		if (!error)
+			p->ref_done = 1;
+	}
+	NMA_UNLOCK();
+	return error;
+}
+
 /*
  * File descriptor's private data destructor.
  *
  * Call nm_register(ifp,0) to stop netmap mode on the interface and
  * revert to normal operation. We expect that np_ifp has not gone.
  */
+/* call with NMA_LOCK held */
 static void
 netmap_dtor_locked(void *data)
 {
@@ -180,43 +378,154 @@
 		selwakeuppri(&na->tx_si, PI_NET);
 		selwakeuppri(&na->rx_si, PI_NET);
 		/* release all buffers */
-		NMA_LOCK();
 		for (i = 0; i < na->num_tx_rings + 1; i++) {
 			struct netmap_ring *ring = na->tx_rings[i].ring;
 			lim = na->tx_rings[i].nkr_num_slots;
 			for (j = 0; j < lim; j++)
 				netmap_free_buf(nifp, ring->slot[j].buf_idx);
+			/* knlist_destroy(&na->tx_rings[i].si.si_note); */
+			mtx_destroy(&na->tx_rings[i].q_lock);
 		}
 		for (i = 0; i < na->num_rx_rings + 1; i++) {
 			struct netmap_ring *ring = na->rx_rings[i].ring;
 			lim = na->rx_rings[i].nkr_num_slots;
 			for (j = 0; j < lim; j++)
 				netmap_free_buf(nifp, ring->slot[j].buf_idx);
+			/* knlist_destroy(&na->rx_rings[i].si.si_note); */
+			mtx_destroy(&na->rx_rings[i].q_lock);
 		}
-		NMA_UNLOCK();
+		/* XXX kqueue(9) needed; these will mirror knlist_init. */
+		/* knlist_destroy(&na->tx_si.si_note); */
+		/* knlist_destroy(&na->rx_si.si_note); */
 		netmap_free_rings(na);
 		wakeup(na);
 	}
 	netmap_if_free(nifp);
 }
 
+static void
+nm_if_rele(struct ifnet *ifp)
+{
+#ifndef NM_BRIDGE
+	if_rele(ifp);
+#else /* NM_BRIDGE */
+	int i, full;
+	struct nm_bridge *b;
+
+	if (strncmp(ifp->if_xname, NM_NAME, sizeof(NM_NAME) - 1)) {
+		if_rele(ifp);
+		return;
+	}
+	if (!DROP_BDG_REF(ifp))
+		return;
+	b = ifp->if_bridge;
+	BDG_LOCK(nm_bridges);
+	BDG_LOCK(b);
+	ND("want to disconnect %s from the bridge", ifp->if_xname);
+	full = 0;
+	for (i = 0; i < NM_BDG_MAXPORTS; i++) {
+		if (b->bdg_ports[i] == ifp) {
+			b->bdg_ports[i] = NULL;
+			bzero(ifp, sizeof(*ifp));
+			free(ifp, M_DEVBUF);
+			break;
+		}
+		else if (b->bdg_ports[i] != NULL)
+			full = 1;
+	}
+	BDG_UNLOCK(b);
+	if (full == 0) {
+		ND("freeing bridge %d", b - nm_bridges);
+		b->namelen = 0;
+	}
+	BDG_UNLOCK(nm_bridges);
+	if (i == NM_BDG_MAXPORTS)
+		D("ouch, cannot find ifp to remove");
+#endif /* NM_BRIDGE */
+}
 
 static void
 netmap_dtor(void *data)
 {
 	struct netmap_priv_d *priv = data;
 	struct ifnet *ifp = priv->np_ifp;
-	struct netmap_adapter *na = NA(ifp);
+	struct netmap_adapter *na;
 
-	na->nm_lock(ifp, NETMAP_REG_LOCK, 0);
-	netmap_dtor_locked(data);
-	na->nm_lock(ifp, NETMAP_REG_UNLOCK, 0);
+	NMA_LOCK();
+	if (ifp) {
+		na = NA(ifp);
+		na->nm_lock(ifp, NETMAP_REG_LOCK, 0);
+		netmap_dtor_locked(data);
+		na->nm_lock(ifp, NETMAP_REG_UNLOCK, 0);
 
-	if_rele(ifp);
+		nm_if_rele(ifp);
+	}
+	if (priv->ref_done) {
+		netmap_memory_deref();
+	}
+	NMA_UNLOCK();
 	bzero(priv, sizeof(*priv));	/* XXX for safety */
 	free(priv, M_DEVBUF);
 }
 
+#ifdef __FreeBSD__
+#include <vm/vm.h>
+#include <vm/vm_param.h>
+#include <vm/vm_object.h>
+#include <vm/vm_page.h>
+#include <vm/vm_pager.h>
+#include <vm/uma.h>
+
+static struct cdev_pager_ops saved_cdev_pager_ops;
+
+static int
+netmap_dev_pager_ctor(void *handle, vm_ooffset_t size, vm_prot_t prot,
+    vm_ooffset_t foff, struct ucred *cred, u_short *color)
+{
+	D("first mmap for %p", handle);
+	return saved_cdev_pager_ops.cdev_pg_ctor(handle,
+			size, prot, foff, cred, color);
+}
+
+static void
+netmap_dev_pager_dtor(void *handle)
+{
+	saved_cdev_pager_ops.cdev_pg_dtor(handle);
+	D("ready to release memory for %p", handle);
+}
+
+
+static struct cdev_pager_ops netmap_cdev_pager_ops = {
+        .cdev_pg_ctor = netmap_dev_pager_ctor,
+        .cdev_pg_dtor = netmap_dev_pager_dtor,
+        .cdev_pg_fault = NULL,
+};
+
+static int
+netmap_mmap_single(struct cdev *cdev, vm_ooffset_t *foff,
+	vm_size_t objsize,  vm_object_t *objp, int prot)
+{
+	vm_object_t obj;
+
+	D("cdev %p foff %jd size %jd objp %p prot %d", cdev,
+	    (intmax_t )*foff, (intmax_t )objsize, objp, prot);
+	obj = vm_pager_allocate(OBJT_DEVICE, cdev, objsize, prot, *foff,
+            curthread->td_ucred);
+	ND("returns obj %p", obj);
+	if (obj == NULL)
+		return EINVAL;
+	if (saved_cdev_pager_ops.cdev_pg_fault == NULL) {
+		D("initialize cdev_pager_ops");
+		saved_cdev_pager_ops = *(obj->un_pager.devp.ops);
+		netmap_cdev_pager_ops.cdev_pg_fault =
+			saved_cdev_pager_ops.cdev_pg_fault;
+	};
+	obj->un_pager.devp.ops = &netmap_cdev_pager_ops;
+	*objp = obj;
+	return 0;
+}
+#endif /* __FreeBSD__ */
+
 
 /*
  * mmap(2) support for the "netmap" device.
@@ -228,6 +537,7 @@
  * Return 0 on success, -1 otherwise.
  */
 
+#ifdef __FreeBSD__
 static int
 netmap_mmap(__unused struct cdev *dev,
 #if __FreeBSD_version < 900000
@@ -238,15 +548,53 @@
 #endif
 	)
 {
+	int error = 0;
+	struct netmap_priv_d *priv;
+
 	if (nprot & PROT_EXEC)
 		return (-1);	// XXX -1 or EINVAL ?
 
+	error = devfs_get_cdevpriv((void **)&priv);
+	if (error == EBADF) {	/* called on fault, memory is initialized */
+		ND(5, "handling fault at ofs 0x%x", offset);
+		error = 0;
+	} else if (error == 0)	/* make sure memory is set */
+		error = netmap_get_memory(priv);
+	if (error)
+		return (error);
+
 	ND("request for offset 0x%x", (uint32_t)offset);
 	*paddr = netmap_ofstophys(offset);
 
-	return (0);
+	return (*paddr ? 0 : ENOMEM);
 }
 
+static int
+netmap_close(struct cdev *dev, int fflag, int devtype, struct thread *td)
+{
+	D("dev %p fflag 0x%x devtype %d td %p", dev, fflag, devtype, td);
+	return 0;
+}
+
+static int
+netmap_open(struct cdev *dev, int oflags, int devtype, struct thread *td)
+{
+	struct netmap_priv_d *priv;
+	int error;
+
+	priv = malloc(sizeof(struct netmap_priv_d), M_DEVBUF,
+			      M_NOWAIT | M_ZERO);
+	if (priv == NULL)
+		return ENOMEM;
+
+	error = devfs_set_cdevpriv(priv, netmap_dtor);
+	if (error)
+	        return error;
+
+	return 0;
+}
+#endif /* __FreeBSD__ */
+
 
 /*
  * Handlers for synchronization of the queues from/to the host.
@@ -316,15 +664,19 @@
  *
  * This routine also does the selrecord if called from the poll handler
  * (we know because td != NULL).
+ *
+ * NOTE: on linux, selrecord() is defined as a macro and uses pwait
+ *     as an additional hidden argument.
  */
 static void
-netmap_sync_from_host(struct netmap_adapter *na, struct thread *td)
+netmap_sync_from_host(struct netmap_adapter *na, struct thread *td, void *pwait)
 {
 	struct netmap_kring *kring = &na->rx_rings[na->num_rx_rings];
 	struct netmap_ring *ring = kring->ring;
 	u_int j, n, lim = kring->nkr_num_slots;
 	u_int k = ring->cur, resvd = ring->reserved;
 
+	(void)pwait;	/* disable unused warnings */
 	na->nm_lock(na->ifp, NETMAP_CORE_LOCK, 0);
 	if (k >= lim) {
 		netmap_ring_reinit(kring);
@@ -363,15 +715,73 @@
 static int
 get_ifp(const char *name, struct ifnet **ifp)
 {
+#ifdef NM_BRIDGE
+	struct ifnet *iter = NULL;
+
+	do {
+		struct nm_bridge *b;
+		int i, l, cand = -1;
+
+		if (strncmp(name, NM_NAME, sizeof(NM_NAME) - 1))
+			break;
+		b = nm_find_bridge(name);
+		if (b == NULL) {
+			D("no bridges available for '%s'", name);
+			return (ENXIO);
+		}
+		/* XXX locking */
+		BDG_LOCK(b);
+		/* lookup in the local list of ports */
+		for (i = 0; i < NM_BDG_MAXPORTS; i++) {
+			iter = b->bdg_ports[i];
+			if (iter == NULL) {
+				if (cand == -1)
+					cand = i; /* potential insert point */
+				continue;
+			}
+			if (!strcmp(iter->if_xname, name)) {
+				ADD_BDG_REF(iter);
+				ND("found existing interface");
+				BDG_UNLOCK(b);
+				break;
+			}
+		}
+		if (i < NM_BDG_MAXPORTS) /* already unlocked */
+			break;
+		if (cand == -1) {
+			D("bridge full, cannot create new port");
+no_port:
+			BDG_UNLOCK(b);
+			*ifp = NULL;
+			return EINVAL;
+		}
+		ND("create new bridge port %s", name);
+		/* space for forwarding list after the ifnet */
+		l = sizeof(*iter) +
+			 sizeof(struct nm_bdg_fwd)*NM_BDG_BATCH ;
+		iter = malloc(l, M_DEVBUF, M_NOWAIT | M_ZERO);
+		if (!iter)
+			goto no_port;
+		strcpy(iter->if_xname, name);
+		bdg_netmap_attach(iter);
+		b->bdg_ports[cand] = iter;
+		iter->if_bridge = b;
+		ADD_BDG_REF(iter);
+		BDG_UNLOCK(b);
+		ND("attaching virtual bridge %p", b);
+	} while (0);
+	*ifp = iter;
+	if (! *ifp)
+#endif /* NM_BRIDGE */
 	*ifp = ifunit_ref(name);
 	if (*ifp == NULL)
 		return (ENXIO);
 	/* can do this if the capability exists and if_pspare[0]
 	 * points to the netmap descriptor.
 	 */
-	if ((*ifp)->if_capabilities & IFCAP_NETMAP && NA(*ifp))
+	if (NETMAP_CAPABLE(*ifp))
 		return 0;	/* valid pointer, we hold the refcount */
-	if_rele(*ifp);
+	nm_if_rele(*ifp);
 	return EINVAL;	// not NETMAP capable
 }
 
@@ -395,7 +805,7 @@
 	u_int i, lim = kring->nkr_num_slots - 1;
 	int errors = 0;
 
-	D("called for %s", kring->na->ifp->if_xname);
+	RD(10, "called for %s", kring->na->ifp->if_xname);
 	if (ring->cur > lim)
 		errors++;
 	for (i = 0; i <= lim; i++) {
@@ -417,9 +827,9 @@
 		int pos = kring - kring->na->tx_rings;
 		int n = kring->na->num_tx_rings + 1;
 
-		D("total %d errors", errors);
+		RD(10, "total %d errors", errors);
 		errors++;
-		D("%s %s[%d] reinit, cur %d -> %d avail %d -> %d",
+		RD(10, "%s %s[%d] reinit, cur %d -> %d avail %d -> %d",
 			kring->na->ifp->if_xname,
 			pos < n ?  "TX" : "RX", pos < n ? pos : pos - n,
 			ring->cur, kring->nr_hwcur,
@@ -491,8 +901,8 @@
  * Return 0 on success, errno otherwise.
  */
 static int
-netmap_ioctl(__unused struct cdev *dev, u_long cmd, caddr_t data,
-	__unused int fflag, struct thread *td)
+netmap_ioctl(struct cdev *dev, u_long cmd, caddr_t data,
+	int fflag, struct thread *td)
 {
 	struct netmap_priv_d *priv = NULL;
 	struct ifnet *ifp;
@@ -502,22 +912,36 @@
 	u_int i, lim;
 	struct netmap_if *nifp;
 
+	(void)dev;	/* UNUSED */
+	(void)fflag;	/* UNUSED */
+#ifdef linux
+#define devfs_get_cdevpriv(pp)				\
+	({ *(struct netmap_priv_d **)pp = ((struct file *)td)->private_data; 	\
+		(*pp ? 0 : ENOENT); })
+
+/* devfs_set_cdevpriv cannot fail on linux */
+#define devfs_set_cdevpriv(p, fn)				\
+	({ ((struct file *)td)->private_data = p; (p ? 0 : EINVAL); })
+
+
+#define devfs_clear_cdevpriv()	do {				\
+		netmap_dtor(priv); ((struct file *)td)->private_data = 0;	\
+	} while (0)
+#endif /* linux */
+
 	CURVNET_SET(TD_TO_VNET(td));
 
 	error = devfs_get_cdevpriv((void **)&priv);
-	if (error != ENOENT && error != 0) {
+	if (error) {
 		CURVNET_RESTORE();
-		return (error);
+		/* XXX ENOENT should be impossible, since the priv
+		 * is now created in the open */
+		return (error == ENOENT ? ENXIO : error);
 	}
 
-	error = 0;	/* Could be ENOENT */
+	nmr->nr_name[sizeof(nmr->nr_name) - 1] = '\0';	/* truncate name */
 	switch (cmd) {
 	case NIOCGINFO:		/* return capabilities etc */
-		/* memsize is always valid */
-		nmr->nr_memsize = nm_mem->nm_totalsize;
-		nmr->nr_offset = 0;
-		nmr->nr_rx_rings = nmr->nr_tx_rings = 0;
-		nmr->nr_rx_slots = nmr->nr_tx_slots = 0;
 		if (nmr->nr_version != NETMAP_API) {
 			D("API mismatch got %d have %d",
 				nmr->nr_version, NETMAP_API);
@@ -525,6 +949,16 @@
 			error = EINVAL;
 			break;
 		}
+		/* update configuration */
+		error = netmap_get_memory(priv);
+		ND("get_memory returned %d", error);
+		if (error)
+			break;
+		/* memsize is always valid */
+		nmr->nr_memsize = nm_mem.nm_totalsize;
+		nmr->nr_offset = 0;
+		nmr->nr_rx_rings = nmr->nr_tx_rings = 0;
+		nmr->nr_rx_slots = nmr->nr_tx_slots = 0;
 		if (nmr->nr_name[0] == '\0')	/* just get memory info */
 			break;
 		error = get_ifp(nmr->nr_name, &ifp); /* get a refcount */
@@ -535,7 +969,7 @@
 		nmr->nr_tx_rings = na->num_tx_rings;
 		nmr->nr_rx_slots = na->num_rx_desc;
 		nmr->nr_tx_slots = na->num_tx_desc;
-		if_rele(ifp);	/* return the refcount */
+		nm_if_rele(ifp);	/* return the refcount */
 		break;
 
 	case NIOCREGIF:
@@ -544,26 +978,26 @@
 			error = EINVAL;
 			break;
 		}
-		if (priv != NULL) {	/* thread already registered */
+		/* ensure allocators are ready */
+		error = netmap_get_memory(priv);
+		ND("get_memory returned %d", error);
+		if (error)
+			break;
+
+		/* protect access to priv from concurrent NIOCREGIF */
+		NMA_LOCK();
+		if (priv->np_ifp != NULL) {	/* thread already registered */
 			error = netmap_set_ringid(priv, nmr->nr_ringid);
+			NMA_UNLOCK();
 			break;
 		}
 		/* find the interface and a reference */
 		error = get_ifp(nmr->nr_name, &ifp); /* keep reference */
-		if (error)
-			break;
-		na = NA(ifp); /* retrieve netmap adapter */
-		/*
-		 * Allocate the private per-thread structure.
-		 * XXX perhaps we can use a blocking malloc ?
-		 */
-		priv = malloc(sizeof(struct netmap_priv_d), M_DEVBUF,
-			      M_NOWAIT | M_ZERO);
-		if (priv == NULL) {
-			error = ENOMEM;
-			if_rele(ifp);   /* return the refcount */
+		if (error) {
+			NMA_UNLOCK();
 			break;
 		}
+		na = NA(ifp); /* retrieve netmap adapter */
 
 		for (i = 10; i > 0; i--) {
 			na->nm_lock(ifp, NETMAP_REG_LOCK, 0);
@@ -575,8 +1009,8 @@
 		if (i == 0) {
 			D("too many NIOCREGIF attempts, give up");
 			error = EINVAL;
-			free(priv, M_DEVBUF);
-			if_rele(ifp);	/* return the refcount */
+			nm_if_rele(ifp);	/* return the refcount */
+			NMA_UNLOCK();
 			break;
 		}
 
@@ -584,7 +1018,7 @@
 		error = netmap_set_ringid(priv, nmr->nr_ringid);
 		if (error)
 			goto error;
-		priv->np_nifp = nifp = netmap_if_new(nmr->nr_name, na);
+		nifp = netmap_if_new(nmr->nr_name, na);
 		if (nifp == NULL) { /* allocation failed */
 			error = ENOMEM;
 		} else if (ifp->if_capenable & IFCAP_NETMAP) {
@@ -593,64 +1027,78 @@
 			/* Otherwise set the card in netmap mode
 			 * and make it use the shared buffers.
 			 */
+			for (i = 0 ; i < na->num_tx_rings + 1; i++)
+				mtx_init(&na->tx_rings[i].q_lock, "nm_txq_lock", MTX_NETWORK_LOCK, MTX_DEF);
+			for (i = 0 ; i < na->num_rx_rings + 1; i++) {
+				mtx_init(&na->rx_rings[i].q_lock, "nm_rxq_lock", MTX_NETWORK_LOCK, MTX_DEF);
+			}
 			error = na->nm_register(ifp, 1); /* mode on */
-			if (error)
+			if (error) {
 				netmap_dtor_locked(priv);
+				netmap_if_free(nifp);
+			}
 		}
 
 		if (error) {	/* reg. failed, release priv and ref */
 error:
 			na->nm_lock(ifp, NETMAP_REG_UNLOCK, 0);
-			if_rele(ifp);	/* return the refcount */
-			bzero(priv, sizeof(*priv));
-			free(priv, M_DEVBUF);
+			nm_if_rele(ifp);	/* return the refcount */
+			priv->np_ifp = NULL;
+			priv->np_nifp = NULL;
+			NMA_UNLOCK();
 			break;
 		}
 
 		na->nm_lock(ifp, NETMAP_REG_UNLOCK, 0);
-		error = devfs_set_cdevpriv(priv, netmap_dtor);
 
-		if (error != 0) {
-			/* could not assign the private storage for the
-			 * thread, call the destructor explicitly.
-			 */
-			netmap_dtor(priv);
-			break;
-		}
+		/* the following assignment is a commitment.
+		 * Readers (i.e., poll and *SYNC) check for
+		 * np_nifp != NULL without locking
+		 */
+		wmb(); /* make sure previous writes are visible to all CPUs */
+		priv->np_nifp = nifp;
+		NMA_UNLOCK();
 
 		/* return the offset of the netmap_if object */
 		nmr->nr_rx_rings = na->num_rx_rings;
 		nmr->nr_tx_rings = na->num_tx_rings;
 		nmr->nr_rx_slots = na->num_rx_desc;
 		nmr->nr_tx_slots = na->num_tx_desc;
-		nmr->nr_memsize = nm_mem->nm_totalsize;
+		nmr->nr_memsize = nm_mem.nm_totalsize;
 		nmr->nr_offset = netmap_if_offset(nifp);
 		break;
 
 	case NIOCUNREGIF:
-		if (priv == NULL) {
+		// XXX we have no data here ?
+		D("deprecated, data is %p", nmr);
+		error = EINVAL;
+		break;
+
+	case NIOCTXSYNC:
+	case NIOCRXSYNC:
+		nifp = priv->np_nifp;
+
+		if (nifp == NULL) {
 			error = ENXIO;
 			break;
 		}
+		rmb(); /* make sure following reads are not from cache */
 
-		/* the interface is unregistered inside the
-		   destructor of the private data. */
-		devfs_clear_cdevpriv();
-		break;
 
-	case NIOCTXSYNC:
-        case NIOCRXSYNC:
-		if (priv == NULL) {
+		ifp = priv->np_ifp;	/* we have a reference */
+
+		if (ifp == NULL) {
+			D("Internal error: nifp != NULL && ifp == NULL");
 			error = ENXIO;
 			break;
 		}
-		ifp = priv->np_ifp;	/* we have a reference */
+
 		na = NA(ifp); /* retrieve netmap adapter */
 		if (priv->np_qfirst == NETMAP_SW_RING) { /* host rings */
 			if (cmd == NIOCTXSYNC)
 				netmap_sync_to_host(na);
 			else
-				netmap_sync_from_host(na, NULL);
+				netmap_sync_from_host(na, NULL, NULL);
 			break;
 		}
 		/* find the last ring to scan */
@@ -679,6 +1127,7 @@
 
 		break;
 
+#ifdef __FreeBSD__
 	case BIOCIMMEDIATE:
 	case BIOCGHDRCMPLT:
 	case BIOCSHDRCMPLT:
@@ -696,9 +1145,14 @@
 		so.so_vnet = ifp->if_vnet;
 		// so->so_proto not null.
 		error = ifioctl(&so, cmd, data, td);
-		if_rele(ifp);
+		nm_if_rele(ifp);
 		break;
 	    }
+
+#else /* linux */
+	default:
+		error = EOPNOTSUPP;
+#endif /* linux */
 	}
 
 	CURVNET_RESTORE();
@@ -715,9 +1169,13 @@
  * selfd or on the global one.
  * Device-dependent parts (locking and sync of tx/rx rings)
  * are done through callbacks.
+ *
+ * On linux, arguments are really pwait, the poll table, and 'td' is struct file *
+ * The first one is remapped to pwait as selrecord() uses the name as an
+ * hidden argument.
  */
 static int
-netmap_poll(__unused struct cdev *dev, int events, struct thread *td)
+netmap_poll(struct cdev *dev, int events, struct thread *td)
 {
 	struct netmap_priv_d *priv = NULL;
 	struct netmap_adapter *na;
@@ -726,10 +1184,19 @@
 	u_int core_lock, i, check_all, want_tx, want_rx, revents = 0;
 	u_int lim_tx, lim_rx;
 	enum {NO_CL, NEED_CL, LOCKED_CL }; /* see below */
+	void *pwait = dev;	/* linux compatibility */
+
+	(void)pwait;
 
 	if (devfs_get_cdevpriv((void **)&priv) != 0 || priv == NULL)
 		return POLLERR;
 
+	if (priv->np_nifp == NULL) {
+		D("No if registered");
+		return POLLERR;
+	}
+	rmb(); /* make sure following reads are not from cache */
+
 	ifp = priv->np_ifp;
 	// XXX check for deleting() ?
 	if ( (ifp->if_capenable & IFCAP_NETMAP) == 0)
@@ -755,7 +1222,7 @@
 		if (want_rx) {
 			kring = &na->rx_rings[lim_rx];
 			if (kring->ring->avail == 0)
-				netmap_sync_from_host(na, td);
+				netmap_sync_from_host(na, td, dev);
 			if (kring->ring->avail > 0) {
 				revents |= want_rx;
 			}
@@ -801,6 +1268,13 @@
 	 * LOCKED_CL	core lock is set, so we need to release it.
 	 */
 	core_lock = (check_all || !na->separate_locks) ? NEED_CL : NO_CL;
+#ifdef NM_BRIDGE
+	/* the bridge uses separate locks */
+	if (na->nm_register == bdg_netmap_reg) {
+		ND("not using core lock for %s", ifp->if_xname);
+		core_lock = NO_CL;
+	}
+#endif /* NM_BRIDGE */
 	if (priv->np_qlast != NETMAP_HW_RING) {
 		lim_tx = lim_rx = priv->np_qlast;
 	}
@@ -965,12 +1439,14 @@
  * kring	N+1	is only used for the selinfo for all queues.
  * Return 0 on success, ENOMEM otherwise.
  *
- * na->num_tx_rings can be set for cards with different tx/rx setups
+ * By default the receive and transmit adapter ring counts are both initialized
+ * to num_queues.  na->num_tx_rings can be set for cards with different tx/rx
+ * setups.
  */
 int
 netmap_attach(struct netmap_adapter *na, int num_queues)
 {
-	int i, n, size;
+	int n, size;
 	void *buf;
 	struct ifnet *ifp = na->ifp;
 
@@ -996,22 +1472,26 @@
 		na->tx_rings = (void *)((char *)buf + sizeof(*na));
 		na->rx_rings = na->tx_rings + na->num_tx_rings + 1;
 		bcopy(na, buf, sizeof(*na));
-		ifp->if_capabilities |= IFCAP_NETMAP;
+		NETMAP_SET_CAPABLE(ifp);
 
 		na = buf;
-		if (na->nm_lock == NULL)
+		/* Core lock initialized here.  Others are initialized after
+		 * netmap_if_new.
+		 */
+		mtx_init(&na->core_lock, "netmap core lock", MTX_NETWORK_LOCK,
+		    MTX_DEF);
+		if (na->nm_lock == NULL) {
+			ND("using default locks for %s", ifp->if_xname);
 			na->nm_lock = netmap_lock_wrapper;
-		mtx_init(&na->core_lock, "netmap core lock", NULL, MTX_DEF);
-		for (i = 0 ; i < na->num_tx_rings + 1; i++)
-			mtx_init(&na->tx_rings[i].q_lock, "netmap txq lock", NULL, MTX_DEF);
-		for (i = 0 ; i < na->num_rx_rings + 1; i++)
-			mtx_init(&na->rx_rings[i].q_lock, "netmap rxq lock", NULL, MTX_DEF);
+		}
 	}
 #ifdef linux
-	D("netdev_ops %p", ifp->netdev_ops);
-	/* prepare a clone of the netdev ops */
-	na->nm_ndo = *ifp->netdev_ops;
-	na->nm_ndo.ndo_start_xmit = netmap_start_linux;
+	if (ifp->netdev_ops) {
+		ND("netdev_ops %p", ifp->netdev_ops);
+		/* prepare a clone of the netdev ops */
+		na->nm_ndo = *ifp->netdev_ops;
+	}
+	na->nm_ndo.ndo_start_xmit = linux_netmap_start;
 #endif
 	D("%s for %s", buf ? "ok" : "failed", ifp->if_xname);
 
@@ -1026,22 +1506,13 @@
 void
 netmap_detach(struct ifnet *ifp)
 {
-	u_int i;
 	struct netmap_adapter *na = NA(ifp);
 
 	if (!na)
 		return;
 
-	for (i = 0; i < na->num_tx_rings + 1; i++) {
-		knlist_destroy(&na->tx_rings[i].si.si_note);
-		mtx_destroy(&na->tx_rings[i].q_lock);
-	}
-	for (i = 0; i < na->num_rx_rings + 1; i++) {
-		knlist_destroy(&na->rx_rings[i].si.si_note);
-		mtx_destroy(&na->rx_rings[i].q_lock);
-	}
-	knlist_destroy(&na->tx_si.si_note);
-	knlist_destroy(&na->rx_si.si_note);
+	mtx_destroy(&na->core_lock);
+
 	bzero(na, sizeof(*na));
 	WNA(ifp) = NULL;
 	free(na, M_DEVBUF);
@@ -1059,7 +1530,7 @@
 	struct netmap_adapter *na = NA(ifp);
 	struct netmap_kring *kring = &na->rx_rings[na->num_rx_rings];
 	u_int i, len = MBUF_LEN(m);
-	int error = EBUSY, lim = kring->nkr_num_slots - 1;
+	u_int error = EBUSY, lim = kring->nkr_num_slots - 1;
 	struct netmap_slot *slot;
 
 	if (netmap_verbose & NM_VERB_HOST)
@@ -1119,9 +1590,13 @@
 		return NULL;	/* nothing to reinitialize */
 
 	if (tx == NR_TX) {
+		if (n >= na->num_tx_rings)
+			return NULL;
 		kring = na->tx_rings + n;
 		new_hwofs = kring->nr_hwcur - new_cur;
 	} else {
+		if (n >= na->num_rx_rings)
+			return NULL;
 		kring = na->rx_rings + n;
 		new_hwofs = kring->nr_hwcur + kring->nr_hwavail - new_cur;
 	}
@@ -1133,10 +1608,20 @@
 	kring->nkr_hwofs = new_hwofs;
 	if (tx == NR_TX)
 		kring->nr_hwavail = kring->nkr_num_slots - 1;
-	D("new hwofs %d on %s %s[%d]",
+	ND(10, "new hwofs %d on %s %s[%d]",
 			kring->nkr_hwofs, na->ifp->if_xname,
 			tx == NR_TX ? "TX" : "RX", n);
 
+#if 0 // def linux
+	/* XXX check that the mappings are correct */
+	/* need ring_nr, adapter->pdev, direction */
+	buffer_info->dma = dma_map_single(&pdev->dev, addr, adapter->rx_buffer_len, DMA_FROM_DEVICE);
+	if (dma_mapping_error(&adapter->pdev->dev, buffer_info->dma)) {
+		D("error mapping rx netmap buffer %d", i);
+		// XXX fix error handling
+	}
+
+#endif /* linux */
 	/*
 	 * Wakeup on the individual and global lock
 	 * We do the wakeup here, but the ring is not yet reconfigured.
@@ -1170,12 +1655,22 @@
 
 	if (!(ifp->if_capenable & IFCAP_NETMAP))
 		return 0;
+	ND(5, "received %s queue %d", work_done ? "RX" : "TX" , q);
 	na = NA(ifp);
+	if (na->na_flags & NAF_SKIP_INTR) {
+		ND("use regular interrupt");
+		return 0;
+	}
+
 	if (work_done) { /* RX path */
+		if (q >= na->num_rx_rings)
+			return 0;	// regular queue
 		r = na->rx_rings + q;
 		r->nr_kflags |= NKR_PENDINTR;
 		main_wq = (na->num_rx_rings > 1) ? &na->rx_si : NULL;
 	} else { /* tx path */
+		if (q >= na->num_tx_rings)
+			return 0;	// regular queue
 		r = na->tx_rings + q;
 		main_wq = (na->num_tx_rings > 1) ? &na->tx_si : NULL;
 		work_done = &q; /* dummy */
@@ -1201,14 +1696,546 @@
 }
 
 
+#ifdef linux	/* linux-specific routines */
+
+/*
+ * Remap linux arguments into the FreeBSD call.
+ * - pwait is the poll table, passed as 'dev';
+ *   If pwait == NULL someone else already woke up before. We can report
+ *   events but they are filtered upstream.
+ *   If pwait != NULL, then pwait->key contains the list of events.
+ * - events is computed from pwait as above.
+ * - file is passed as 'td';
+ */
+static u_int
+linux_netmap_poll(struct file * file, struct poll_table_struct *pwait)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,4,0)
+	int events = pwait ? pwait->key : POLLIN | POLLOUT;
+#else /* in 3.4.0 field 'key' was renamed to '_key' */
+	int events = pwait ? pwait->_key : POLLIN | POLLOUT;
+#endif
+	return netmap_poll((void *)pwait, events, (void *)file);
+}
+
+static int
+linux_netmap_mmap(struct file *f, struct vm_area_struct *vma)
+{
+	int lut_skip, i, j;
+	int user_skip = 0;
+	struct lut_entry *l_entry;
+	int error = 0;
+	unsigned long off, tomap;
+	/*
+	 * vma->vm_start: start of mapping user address space
+	 * vma->vm_end: end of the mapping user address space
+	 * vma->vm_pfoff: offset of first page in the device
+	 */
+
+	// XXX security checks
+
+	error = netmap_get_memory(f->private_data);
+	ND("get_memory returned %d", error);
+	if (error)
+	    return -error;
+
+	off = vma->vm_pgoff << PAGE_SHIFT; /* offset in bytes */
+	tomap = vma->vm_end - vma->vm_start;
+	for (i = 0; i < NETMAP_POOLS_NR; i++) {  /* loop through obj_pools */
+		const struct netmap_obj_pool *p = &nm_mem.pools[i];
+		/*
+		 * In each pool memory is allocated in clusters
+		 * of size _clustsize, each containing clustentries
+		 * entries. For each object k we already store the
+		 * vtophys mapping in lut[k] so we use that, scanning
+		 * the lut[] array in steps of clustentries,
+		 * and we map each cluster (not individual pages,
+		 * it would be overkill).
+		 */
+
+		/*
+		 * We interpret vm_pgoff as an offset into the whole
+		 * netmap memory, as if all clusters where contiguous.
+		 */
+		for (lut_skip = 0, j = 0; j < p->_numclusters; j++, lut_skip += p->clustentries) {
+			unsigned long paddr, mapsize;
+			if (p->_clustsize <= off) {
+				off -= p->_clustsize;
+				continue;
+			}
+			l_entry = &p->lut[lut_skip]; /* first obj in the cluster */
+			paddr = l_entry->paddr + off;
+			mapsize = p->_clustsize - off;
+			off = 0;
+			if (mapsize > tomap)
+				mapsize = tomap;
+			ND("remap_pfn_range(%lx, %lx, %lx)",
+				vma->vm_start + user_skip,
+				paddr >> PAGE_SHIFT, mapsize);
+			if (remap_pfn_range(vma, vma->vm_start + user_skip,
+					paddr >> PAGE_SHIFT, mapsize,
+					vma->vm_page_prot))
+				return -EAGAIN; // XXX check return value
+			user_skip += mapsize;
+			tomap -= mapsize;
+			if (tomap == 0)
+				goto done;
+		}
+	}
+done:
+
+	return 0;
+}
+
+static netdev_tx_t
+linux_netmap_start(struct sk_buff *skb, struct net_device *dev)
+{
+	netmap_start(dev, skb);
+	return (NETDEV_TX_OK);
+}
+
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,37)	// XXX was 38
+#define LIN_IOCTL_NAME	.ioctl
+int
+linux_netmap_ioctl(struct inode *inode, struct file *file, u_int cmd, u_long data /* arg */)
+#else
+#define LIN_IOCTL_NAME	.unlocked_ioctl
+long
+linux_netmap_ioctl(struct file *file, u_int cmd, u_long data /* arg */)
+#endif
+{
+	int ret;
+	struct nmreq nmr;
+	bzero(&nmr, sizeof(nmr));
+
+	if (data && copy_from_user(&nmr, (void *)data, sizeof(nmr) ) != 0)
+		return -EFAULT;
+	ret = netmap_ioctl(NULL, cmd, (caddr_t)&nmr, 0, (void *)file);
+	if (data && copy_to_user((void*)data, &nmr, sizeof(nmr) ) != 0)
+		return -EFAULT;
+	return -ret;
+}
+
+
+static int
+netmap_release(struct inode *inode, struct file *file)
+{
+	(void)inode;	/* UNUSED */
+	if (file->private_data)
+		netmap_dtor(file->private_data);
+	return (0);
+}
+
+static int
+linux_netmap_open(struct inode *inode, struct file *file)
+{
+	struct netmap_priv_d *priv;
+	(void)inode;	/* UNUSED */
+
+	priv = malloc(sizeof(struct netmap_priv_d), M_DEVBUF,
+			      M_NOWAIT | M_ZERO);
+	if (priv == NULL)
+		return -ENOMEM;
+
+	file->private_data = priv;
+
+	return (0);
+}
+
+static struct file_operations netmap_fops = {
+    .open = linux_netmap_open,
+    .mmap = linux_netmap_mmap,
+    LIN_IOCTL_NAME = linux_netmap_ioctl,
+    .poll = linux_netmap_poll,
+    .release = netmap_release,
+};
+
+static struct miscdevice netmap_cdevsw = {	/* same name as FreeBSD */
+	MISC_DYNAMIC_MINOR,
+	"netmap",
+	&netmap_fops,
+};
+
+static int netmap_init(void);
+static void netmap_fini(void);
+
+/* Errors have negative values on linux */
+static int linux_netmap_init(void)
+{
+	return -netmap_init();
+}
+
+module_init(linux_netmap_init);
+module_exit(netmap_fini);
+/* export certain symbols to other modules */
+EXPORT_SYMBOL(netmap_attach);		// driver attach routines
+EXPORT_SYMBOL(netmap_detach);		// driver detach routines
+EXPORT_SYMBOL(netmap_ring_reinit);	// ring init on error
+EXPORT_SYMBOL(netmap_buffer_lut);
+EXPORT_SYMBOL(netmap_total_buffers);	// index check
+EXPORT_SYMBOL(netmap_buffer_base);
+EXPORT_SYMBOL(netmap_reset);		// ring init routines
+EXPORT_SYMBOL(netmap_buf_size);
+EXPORT_SYMBOL(netmap_rx_irq);		// default irq handler
+EXPORT_SYMBOL(netmap_no_pendintr);	// XXX mitigation - should go away
+
+
+MODULE_AUTHOR("http://info.iet.unipi.it/~luigi/netmap/");
+MODULE_DESCRIPTION("The netmap packet I/O framework");
+MODULE_LICENSE("Dual BSD/GPL"); /* the code here is all BSD. */
+
+#else /* __FreeBSD__ */
+
 static struct cdevsw netmap_cdevsw = {
 	.d_version = D_VERSION,
 	.d_name = "netmap",
+	.d_open = netmap_open,
 	.d_mmap = netmap_mmap,
+	.d_mmap_single = netmap_mmap_single,
 	.d_ioctl = netmap_ioctl,
 	.d_poll = netmap_poll,
+	.d_close = netmap_close,
 };
+#endif /* __FreeBSD__ */
 
+#ifdef NM_BRIDGE
+/*
+ *---- support for virtual bridge -----
+ */
+
+/* ----- FreeBSD if_bridge hash function ------- */
+
+/*
+ * The following hash function is adapted from "Hash Functions" by Bob Jenkins
+ * ("Algorithm Alley", Dr. Dobbs Journal, September 1997).
+ *
+ * http://www.burtleburtle.net/bob/hash/spooky.html
+ */
+#define mix(a, b, c)                                                    \
+do {                                                                    \
+        a -= b; a -= c; a ^= (c >> 13);                                 \
+        b -= c; b -= a; b ^= (a << 8);                                  \
+        c -= a; c -= b; c ^= (b >> 13);                                 \
+        a -= b; a -= c; a ^= (c >> 12);                                 \
+        b -= c; b -= a; b ^= (a << 16);                                 \
+        c -= a; c -= b; c ^= (b >> 5);                                  \
+        a -= b; a -= c; a ^= (c >> 3);                                  \
+        b -= c; b -= a; b ^= (a << 10);                                 \
+        c -= a; c -= b; c ^= (b >> 15);                                 \
+} while (/*CONSTCOND*/0)
+
+static __inline uint32_t
+nm_bridge_rthash(const uint8_t *addr)
+{
+        uint32_t a = 0x9e3779b9, b = 0x9e3779b9, c = 0; // hask key
+
+        b += addr[5] << 8;
+        b += addr[4];
+        a += addr[3] << 24;
+        a += addr[2] << 16;
+        a += addr[1] << 8;
+        a += addr[0];
+
+        mix(a, b, c);
+#define BRIDGE_RTHASH_MASK	(NM_BDG_HASH-1)
+        return (c & BRIDGE_RTHASH_MASK);
+}
+
+#undef mix
+
+
+static int
+bdg_netmap_reg(struct ifnet *ifp, int onoff)
+{
+	int i, err = 0;
+	struct nm_bridge *b = ifp->if_bridge;
+
+	BDG_LOCK(b);
+	if (onoff) {
+		/* the interface must be already in the list.
+		 * only need to mark the port as active
+		 */
+		ND("should attach %s to the bridge", ifp->if_xname);
+		for (i=0; i < NM_BDG_MAXPORTS; i++)
+			if (b->bdg_ports[i] == ifp)
+				break;
+		if (i == NM_BDG_MAXPORTS) {
+			D("no more ports available");
+			err = EINVAL;
+			goto done;
+		}
+		ND("setting %s in netmap mode", ifp->if_xname);
+		ifp->if_capenable |= IFCAP_NETMAP;
+		NA(ifp)->bdg_port = i;
+		b->act_ports |= (1<<i);
+		b->bdg_ports[i] = ifp;
+	} else {
+		/* should be in the list, too -- remove from the mask */
+		ND("removing %s from netmap mode", ifp->if_xname);
+		ifp->if_capenable &= ~IFCAP_NETMAP;
+		i = NA(ifp)->bdg_port;
+		b->act_ports &= ~(1<<i);
+	}
+done:
+	BDG_UNLOCK(b);
+	return err;
+}
+
+
+static int
+nm_bdg_flush(struct nm_bdg_fwd *ft, int n, struct ifnet *ifp)
+{
+	int i, ifn;
+	uint64_t all_dst, dst;
+	uint32_t sh, dh;
+	uint64_t mysrc = 1 << NA(ifp)->bdg_port;
+	uint64_t smac, dmac;
+	struct netmap_slot *slot;
+	struct nm_bridge *b = ifp->if_bridge;
+
+	ND("prepare to send %d packets, act_ports 0x%x", n, b->act_ports);
+	/* only consider valid destinations */
+	all_dst = (b->act_ports & ~mysrc);
+	/* first pass: hash and find destinations */
+	for (i = 0; likely(i < n); i++) {
+		uint8_t *buf = ft[i].buf;
+		dmac = le64toh(*(uint64_t *)(buf)) & 0xffffffffffff;
+		smac = le64toh(*(uint64_t *)(buf + 4));
+		smac >>= 16;
+		if (unlikely(netmap_verbose)) {
+		    uint8_t *s = buf+6, *d = buf;
+		    D("%d len %4d %02x:%02x:%02x:%02x:%02x:%02x -> %02x:%02x:%02x:%02x:%02x:%02x",
+			i,
+			ft[i].len,
+			s[0], s[1], s[2], s[3], s[4], s[5],
+			d[0], d[1], d[2], d[3], d[4], d[5]);
+		}
+		/*
+		 * The hash is somewhat expensive, there might be some
+		 * worthwhile optimizations here.
+		 */
+		if ((buf[6] & 1) == 0) { /* valid src */
+		    	uint8_t *s = buf+6;
+			sh = nm_bridge_rthash(buf+6); // XXX hash of source
+			/* update source port forwarding entry */
+			b->ht[sh].mac = smac;	/* XXX expire ? */
+			b->ht[sh].ports = mysrc;
+			if (netmap_verbose)
+			    D("src %02x:%02x:%02x:%02x:%02x:%02x on port %d",
+				s[0], s[1], s[2], s[3], s[4], s[5], NA(ifp)->bdg_port);
+		}
+		dst = 0;
+		if ( (buf[0] & 1) == 0) { /* unicast */
+		    	uint8_t *d = buf;
+			dh = nm_bridge_rthash(buf); // XXX hash of dst
+			if (b->ht[dh].mac == dmac) {	/* found dst */
+				dst = b->ht[dh].ports;
+				if (netmap_verbose)
+				    D("dst %02x:%02x:%02x:%02x:%02x:%02x to port %x",
+					d[0], d[1], d[2], d[3], d[4], d[5], (uint32_t)(dst >> 16));
+			}
+		}
+		if (dst == 0)
+			dst = all_dst;
+		dst &= all_dst; /* only consider valid ports */
+		if (unlikely(netmap_verbose))
+			D("pkt goes to ports 0x%x", (uint32_t)dst);
+		ft[i].dst = dst;
+	}
+
+	/* second pass, scan interfaces and forward */
+	all_dst = (b->act_ports & ~mysrc);
+	for (ifn = 0; all_dst; ifn++) {
+		struct ifnet *dst_ifp = b->bdg_ports[ifn];
+		struct netmap_adapter *na;
+		struct netmap_kring *kring;
+		struct netmap_ring *ring;
+		int j, lim, sent, locked;
+
+		if (!dst_ifp)
+			continue;
+		ND("scan port %d %s", ifn, dst_ifp->if_xname);
+		dst = 1 << ifn;
+		if ((dst & all_dst) == 0)	/* skip if not set */
+			continue;
+		all_dst &= ~dst;	/* clear current node */
+		na = NA(dst_ifp);
+
+		ring = NULL;
+		kring = NULL;
+		lim = sent = locked = 0;
+		/* inside, scan slots */
+		for (i = 0; likely(i < n); i++) {
+			if ((ft[i].dst & dst) == 0)
+				continue;	/* not here */
+			if (!locked) {
+				kring = &na->rx_rings[0];
+				ring = kring->ring;
+				lim = kring->nkr_num_slots - 1;
+				na->nm_lock(dst_ifp, NETMAP_RX_LOCK, 0);
+				locked = 1;
+			}
+			if (unlikely(kring->nr_hwavail >= lim)) {
+				if (netmap_verbose)
+					D("rx ring full on %s", ifp->if_xname);
+				break;
+			}
+			j = kring->nr_hwcur + kring->nr_hwavail;
+			if (j > lim)
+				j -= kring->nkr_num_slots;
+			slot = &ring->slot[j];
+			ND("send %d %d bytes at %s:%d", i, ft[i].len, dst_ifp->if_xname, j);
+			pkt_copy(ft[i].buf, NMB(slot), ft[i].len);
+			slot->len = ft[i].len;
+			kring->nr_hwavail++;
+			sent++;
+		}
+		if (locked) {
+			ND("sent %d on %s", sent, dst_ifp->if_xname);
+			if (sent)
+				selwakeuppri(&kring->si, PI_NET);
+			na->nm_lock(dst_ifp, NETMAP_RX_UNLOCK, 0);
+		}
+	}
+	return 0;
+}
+
+/*
+ * main dispatch routine
+ */
+static int
+bdg_netmap_txsync(struct ifnet *ifp, u_int ring_nr, int do_lock)
+{
+	struct netmap_adapter *na = NA(ifp);
+	struct netmap_kring *kring = &na->tx_rings[ring_nr];
+	struct netmap_ring *ring = kring->ring;
+	int i, j, k, lim = kring->nkr_num_slots - 1;
+	struct nm_bdg_fwd *ft = (struct nm_bdg_fwd *)(ifp + 1);
+	int ft_i;	/* position in the forwarding table */
+
+	k = ring->cur;
+	if (k > lim)
+		return netmap_ring_reinit(kring);
+	if (do_lock)
+		na->nm_lock(ifp, NETMAP_TX_LOCK, ring_nr);
+
+	if (netmap_bridge <= 0) { /* testing only */
+		j = k; // used all
+		goto done;
+	}
+	if (netmap_bridge > NM_BDG_BATCH)
+		netmap_bridge = NM_BDG_BATCH;
+
+	ft_i = 0;	/* start from 0 */
+	for (j = kring->nr_hwcur; likely(j != k); j = unlikely(j == lim) ? 0 : j+1) {
+		struct netmap_slot *slot = &ring->slot[j];
+		int len = ft[ft_i].len = slot->len;
+		char *buf = ft[ft_i].buf = NMB(slot);
+
+		prefetch(buf);
+		if (unlikely(len < 14))
+			continue;
+		if (unlikely(++ft_i == netmap_bridge))
+			ft_i = nm_bdg_flush(ft, ft_i, ifp);
+	}
+	if (ft_i)
+		ft_i = nm_bdg_flush(ft, ft_i, ifp);
+	/* count how many packets we sent */
+	i = k - j;
+	if (i < 0)
+		i += kring->nkr_num_slots;
+	kring->nr_hwavail = kring->nkr_num_slots - 1 - i;
+	if (j != k)
+		D("early break at %d/ %d, avail %d", j, k, kring->nr_hwavail);
+
+done:
+	kring->nr_hwcur = j;
+	ring->avail = kring->nr_hwavail;
+	if (do_lock)
+		na->nm_lock(ifp, NETMAP_TX_UNLOCK, ring_nr);
+
+	if (netmap_verbose)
+		D("%s ring %d lock %d", ifp->if_xname, ring_nr, do_lock);
+	return 0;
+}
+
+static int
+bdg_netmap_rxsync(struct ifnet *ifp, u_int ring_nr, int do_lock)
+{
+	struct netmap_adapter *na = NA(ifp);
+	struct netmap_kring *kring = &na->rx_rings[ring_nr];
+	struct netmap_ring *ring = kring->ring;
+	u_int j, n, lim = kring->nkr_num_slots - 1;
+	u_int k = ring->cur, resvd = ring->reserved;
+
+	ND("%s ring %d lock %d avail %d",
+		ifp->if_xname, ring_nr, do_lock, kring->nr_hwavail);
+
+	if (k > lim)
+		return netmap_ring_reinit(kring);
+	if (do_lock)
+		na->nm_lock(ifp, NETMAP_RX_LOCK, ring_nr);
+
+	/* skip past packets that userspace has released */
+	j = kring->nr_hwcur;    /* netmap ring index */
+	if (resvd > 0) {
+		if (resvd + ring->avail >= lim + 1) {
+			D("XXX invalid reserve/avail %d %d", resvd, ring->avail);
+			ring->reserved = resvd = 0; // XXX panic...
+		}
+		k = (k >= resvd) ? k - resvd : k + lim + 1 - resvd;
+	}
+
+	if (j != k) { /* userspace has released some packets. */
+		n = k - j;
+		if (n < 0)
+			n += kring->nkr_num_slots;
+		ND("userspace releases %d packets", n);
+                for (n = 0; likely(j != k); n++) {
+                        struct netmap_slot *slot = &ring->slot[j];
+                        void *addr = NMB(slot);
+
+                        if (addr == netmap_buffer_base) { /* bad buf */
+                                if (do_lock)
+                                        na->nm_lock(ifp, NETMAP_RX_UNLOCK, ring_nr);
+                                return netmap_ring_reinit(kring);
+                        }
+			/* decrease refcount for buffer */
+
+			slot->flags &= ~NS_BUF_CHANGED;
+                        j = unlikely(j == lim) ? 0 : j + 1;
+                }
+                kring->nr_hwavail -= n;
+                kring->nr_hwcur = k;
+        }
+        /* tell userspace that there are new packets */
+        ring->avail = kring->nr_hwavail - resvd;
+
+	if (do_lock)
+		na->nm_lock(ifp, NETMAP_RX_UNLOCK, ring_nr);
+	return 0;
+}
+
+static void
+bdg_netmap_attach(struct ifnet *ifp)
+{
+	struct netmap_adapter na;
+
+	ND("attaching virtual bridge");
+	bzero(&na, sizeof(na));
+
+	na.ifp = ifp;
+	na.separate_locks = 1;
+	na.num_tx_desc = NM_BRIDGE_RINGSIZE;
+	na.num_rx_desc = NM_BRIDGE_RINGSIZE;
+	na.nm_txsync = bdg_netmap_txsync;
+	na.nm_rxsync = bdg_netmap_rxsync;
+	na.nm_register = bdg_netmap_reg;
+	netmap_attach(&na, 1);
+}
+
+#endif /* NM_BRIDGE */
 
 static struct cdev *netmap_dev; /* /dev/netmap character device. */
 
@@ -1228,13 +2255,20 @@
 
 	error = netmap_memory_init();
 	if (error != 0) {
-		printf("netmap: unable to initialize the memory allocator.");
+		printf("netmap: unable to initialize the memory allocator.\n");
 		return (error);
 	}
-	printf("netmap: loaded module with %d Mbytes\n",
-		(int)(nm_mem->nm_totalsize >> 20));
+	printf("netmap: loaded module\n");
 	netmap_dev = make_dev(&netmap_cdevsw, 0, UID_ROOT, GID_WHEEL, 0660,
 			      "netmap");
+
+#ifdef NM_BRIDGE
+	{
+	int i;
+	for (i = 0; i < NM_BRIDGES; i++)
+		mtx_init(&nm_bridges[i].bdg_lock, "bdg lock", "bdg_lock", MTX_DEF);
+	}
+#endif
 	return (error);
 }
 
@@ -1253,6 +2287,7 @@
 }
 
 
+#ifdef __FreeBSD__
 /*
  * Kernel entry point.
  *
@@ -1284,3 +2319,4 @@
 
 
 DEV_MODULE(netmap, netmap_loader, NULL);
+#endif /* __FreeBSD__ */
diff -ruN sys/dev/netmap.orig/netmap_kern.h sys/dev/netmap/netmap_kern.h
--- sys/dev/netmap.orig/netmap_kern.h	2013-01-09 01:04:19.000000000 +0100
+++ sys/dev/netmap/netmap_kern.h	2013-01-09 01:05:09.000000000 +0100
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) 2011-2012 Matteo Landi, Luigi Rizzo. All rights reserved.
- * 
+ *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
@@ -9,7 +9,7 @@
  *   2. Redistributions in binary form must reproduce the above copyright
  *      notice, this list of conditions and the following disclaimer in the
  *    documentation and/or other materials provided with the distribution.
- * 
+ *
  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
@@ -24,8 +24,8 @@
  */
 
 /*
- * $FreeBSD: releng/9.1/sys/dev/netmap/netmap_kern.h 235549 2012-05-17 15:02:51Z luigi $
- * $Id: netmap_kern.h 10602 2012-02-21 16:47:55Z luigi $
+ * $FreeBSD: head/sys/dev/netmap/netmap_kern.h 241719 2012-10-19 04:13:12Z luigi $
+ * $Id: netmap_kern.h 11829 2012-09-26 04:06:34Z luigi $
  *
  * The header contains the definitions of constants and function
  * prototypes used only in kernelspace.
@@ -37,6 +37,9 @@
 #define NETMAP_MEM2    // use the new memory allocator
 
 #if defined(__FreeBSD__)
+#define likely(x)	__builtin_expect(!!(x), 1)
+#define unlikely(x)	__builtin_expect(!!(x), 0)
+
 #define	NM_LOCK_T	struct mtx
 #define	NM_SELINFO_T	struct selinfo
 #define	MBUF_LEN(m)	((m)->m_pkthdr.len)
@@ -46,12 +49,34 @@
 #define	NM_SELINFO_T	wait_queue_head_t
 #define	MBUF_LEN(m)	((m)->len)
 #define	NM_SEND_UP(ifp, m)	netif_rx(m)
+
+#ifndef DEV_NETMAP
+#define DEV_NETMAP
+#endif
+
+/*
+ * IFCAP_NETMAP goes into net_device's priv_flags (if_capenable).
+ * This was 16 bits up to linux 2.6.36, so we need a 16 bit value on older
+ * platforms and tolerate the clash with IFF_DYNAMIC and IFF_BRIDGE_PORT.
+ * For the 32-bit value, 0x100000 has no clashes until at least 3.5.1
+ */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,37)
+#define IFCAP_NETMAP	0x8000
 #else
-#error unsupported platform
+#define IFCAP_NETMAP	0x100000
 #endif
 
-#ifdef MALLOC_DECLARE
-MALLOC_DECLARE(M_NETMAP);
+#elif defined (__APPLE__)
+#warning apple support is incomplete.
+#define likely(x)	__builtin_expect(!!(x), 1)
+#define unlikely(x)	__builtin_expect(!!(x), 0)
+#define	NM_LOCK_T	IOLock *
+#define	NM_SELINFO_T	struct selinfo
+#define	MBUF_LEN(m)	((m)->m_pkthdr.len)
+#define	NM_SEND_UP(ifp, m)	((ifp)->if_input)(ifp, m)
+
+#else
+#error unsupported platform
 #endif
 
 #define ND(format, ...)
@@ -63,7 +88,19 @@
 		(int)__xxts.tv_sec % 1000, (int)__xxts.tv_usec,	\
 		__FUNCTION__, __LINE__, ##__VA_ARGS__);		\
 	} while (0)
- 
+
+/* rate limited, lps indicates how many per second */
+#define RD(lps, format, ...)					\
+	do {							\
+		static int t0, __cnt;				\
+		if (t0 != time_second) {			\
+			t0 = time_second;			\
+			__cnt = 0;				\
+		}						\
+		if (__cnt++ < lps)				\
+			D(format, ##__VA_ARGS__);		\
+	} while (0)
+
 struct netmap_adapter;
 
 /*
@@ -103,6 +140,18 @@
  * support netmap operation.
  */
 struct netmap_adapter {
+	/*
+	 * On linux we do not have a good way to tell if an interface
+	 * is netmap-capable. So we use the following trick:
+	 * NA(ifp) points here, and the first entry (which hopefully
+	 * always exists and is at least 32 bits) contains a magic
+	 * value which we can use to detect that the interface is good.
+	 */
+	uint32_t magic;
+	uint32_t na_flags;	/* future place for IFCAP_NETMAP */
+#define NAF_SKIP_INTR	1	/* use the regular interrupt handler.
+				 * useful during initialization
+				 */
 	int refcount; /* number of user-space descriptors using this
 			 interface, which is equal to the number of
 			 struct netmap_if objs in the mapped region. */
@@ -118,12 +167,11 @@
 	int separate_locks; /* set if the interface suports different
 			       locks for rx, tx and core. */
 
-	u_int num_rx_rings; /* number of tx/rx ring pairs */
-	u_int num_tx_rings; // if nonzero, overrides num_rx_rings
+	u_int num_rx_rings; /* number of adapter receive rings */
+	u_int num_tx_rings; /* number of adapter transmit rings */
 
 	u_int num_tx_desc; /* number of descriptor in each queue */
 	u_int num_rx_desc;
-	//u_int buff_size;	// XXX deprecate, use NETMAP_BUF_SIZE
 
 	/* tx_rings and rx_rings are private but allocated
 	 * as a contiguous chunk of memory. Each array has
@@ -150,13 +198,16 @@
 	void (*nm_lock)(struct ifnet *, int what, u_int ringid);
 	int (*nm_txsync)(struct ifnet *, u_int ring, int lock);
 	int (*nm_rxsync)(struct ifnet *, u_int ring, int lock);
+
+	int bdg_port;
 #ifdef linux
 	struct net_device_ops nm_ndo;
+	int if_refcount;	// XXX additions for bridge
 #endif /* linux */
 };
 
 /*
- * The combination of "enable" (ifp->if_capabilities &IFCAP_NETMAP)
+ * The combination of "enable" (ifp->if_capenable & IFCAP_NETMAP)
  * and refcount gives the status of the interface, namely:
  *
  *	enable	refcount	Status
@@ -212,7 +263,7 @@
 	enum txrx tx, int n, u_int new_cur);
 int netmap_ring_reinit(struct netmap_kring *);
 
-extern int netmap_buf_size;
+extern u_int netmap_buf_size;
 #define NETMAP_BUF_SIZE	netmap_buf_size
 extern int netmap_mitigate;
 extern int netmap_no_pendintr;
@@ -239,7 +290,38 @@
 #endif
 #define	NA(_ifp)	((struct netmap_adapter *)WNA(_ifp))
 
+/*
+ * Macros to determine if an interface is netmap capable or netmap enabled.
+ * See the magic field in struct netmap_adapter.
+ */
+#ifdef __FreeBSD__
+/*
+ * on FreeBSD just use if_capabilities and if_capenable.
+ */
+#define NETMAP_CAPABLE(ifp)	(NA(ifp) &&		\
+	(ifp)->if_capabilities & IFCAP_NETMAP )
+
+#define	NETMAP_SET_CAPABLE(ifp)				\
+	(ifp)->if_capabilities |= IFCAP_NETMAP
+
+#else	/* linux */
+
+/*
+ * on linux:
+ * we check if NA(ifp) is set and its first element has a related
+ * magic value. The capenable is within the struct netmap_adapter.
+ */
+#define	NETMAP_MAGIC	0x52697a7a
+
+#define NETMAP_CAPABLE(ifp)	(NA(ifp) &&		\
+	((uint32_t)(uintptr_t)NA(ifp) ^ NA(ifp)->magic) == NETMAP_MAGIC )
 
+#define	NETMAP_SET_CAPABLE(ifp)				\
+	NA(ifp)->magic = ((uint32_t)(uintptr_t)NA(ifp)) ^ NETMAP_MAGIC
+
+#endif	/* linux */
+
+#ifdef __FreeBSD__
 /* Callback invoked by the dma machinery after a successfull dmamap_load */
 static void netmap_dmamap_cb(__unused void *arg,
     __unused bus_dma_segment_t * segs, __unused int nseg, __unused int error)
@@ -267,6 +349,48 @@
 		    netmap_dmamap_cb, NULL, BUS_DMA_NOWAIT);
 	}
 }
+#else /* linux */
+
+/*
+ * XXX How do we redefine these functions:
+ *
+ * on linux we need
+ *	dma_map_single(&pdev->dev, virt_addr, len, direction)
+ *	dma_unmap_single(&adapter->pdev->dev, phys_addr, len, direction
+ * The len can be implicit (on netmap it is NETMAP_BUF_SIZE)
+ * unfortunately the direction is not, so we need to change
+ * something to have a cross API
+ */
+#define netmap_load_map(_t, _m, _b)
+#define netmap_reload_map(_t, _m, _b)
+#if 0
+	struct e1000_buffer *buffer_info =  &tx_ring->buffer_info[l];
+	/* set time_stamp *before* dma to help avoid a possible race */
+	buffer_info->time_stamp = jiffies;
+	buffer_info->mapped_as_page = false;
+	buffer_info->length = len;
+	//buffer_info->next_to_watch = l;
+	/* reload dma map */
+	dma_unmap_single(&adapter->pdev->dev, buffer_info->dma,
+			NETMAP_BUF_SIZE, DMA_TO_DEVICE);
+	buffer_info->dma = dma_map_single(&adapter->pdev->dev,
+			addr, NETMAP_BUF_SIZE, DMA_TO_DEVICE);
+
+	if (dma_mapping_error(&adapter->pdev->dev, buffer_info->dma)) {
+		D("dma mapping error");
+		/* goto dma_error; See e1000_put_txbuf() */
+		/* XXX reset */
+	}
+	tx_desc->buffer_addr = htole64(buffer_info->dma); //XXX
+
+#endif
+
+/*
+ * The bus_dmamap_sync() can be one of wmb() or rmb() depending on direction.
+ */
+#define bus_dmamap_sync(_a, _b, _c)
+
+#endif /* linux */
 
 /*
  * functions to map NIC to KRING indexes (n2k) and vice versa (k2n)
@@ -322,7 +446,7 @@
 NMB(struct netmap_slot *slot)
 {
 	uint32_t i = slot->buf_idx;
-	return (i >= netmap_total_buffers) ?  NMB_VA(0) : NMB_VA(i);
+	return (unlikely(i >= netmap_total_buffers)) ?  NMB_VA(0) : NMB_VA(i);
 }
 
 static inline void *
@@ -341,4 +465,6 @@
 /* default functions to handle rx/tx interrupts */
 int netmap_rx_irq(struct ifnet *, int, int *);
 #define netmap_tx_irq(_n, _q) netmap_rx_irq(_n, _q, NULL)
+
+extern int netmap_copy;
 #endif /* _NET_NETMAP_KERN_H_ */
diff -ruN sys/dev/netmap.orig/netmap_mem1.c sys/dev/netmap/netmap_mem1.c
--- sys/dev/netmap.orig/netmap_mem1.c	2013-01-09 01:04:19.000000000 +0100
+++ sys/dev/netmap/netmap_mem1.c	2013-01-09 01:05:09.000000000 +0100
@@ -24,7 +24,7 @@
  */
 
 /*
- * $FreeBSD: releng/9.1/sys/dev/netmap/netmap_mem1.c 235561 2012-05-17 20:04:24Z luigi $
+ * $FreeBSD: head/sys/dev/netmap/netmap_mem1.c 234227 2012-04-13 16:03:07Z luigi $
  *
  * The original netmap memory allocator, using a single large
  * chunk of memory allocated with contigmalloc.
diff -ruN sys/dev/netmap.orig/netmap_mem2.c sys/dev/netmap/netmap_mem2.c
--- sys/dev/netmap.orig/netmap_mem2.c	2013-01-09 01:04:19.000000000 +0100
+++ sys/dev/netmap/netmap_mem2.c	2013-01-09 01:05:09.000000000 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Matteo Landi, Luigi Rizzo. All rights reserved.
+ * Copyright (C) 2012 Matteo Landi, Luigi Rizzo, Giuseppe Lettieri. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
@@ -24,20 +24,20 @@
  */
 
 /*
- * $FreeBSD: releng/9.1/sys/dev/netmap/netmap_mem2.c 235561 2012-05-17 20:04:24Z luigi $
- * $Id: netmap_mem2.c 10830 2012-03-22 18:06:01Z luigi $
+ * $FreeBSD: head/sys/dev/netmap/netmap_mem2.c 241750 2012-10-19 19:28:35Z emaste $
+ * $Id: netmap_mem2.c 11881 2012-10-18 23:24:15Z luigi $
  *
- * New memory allocator for netmap
+ * (New) memory allocator for netmap
  */
 
 /*
- * The new version allocates three regions:
- *	nm_if_pool      for the struct netmap_if
- *	nm_ring_pool    for the struct netmap_ring
- *	nm_buf_pool    for the packet buffers.
+ * This allocator creates three memory regions:
+ *	nm_if_pool	for the struct netmap_if
+ *	nm_ring_pool	for the struct netmap_ring
+ *	nm_buf_pool	for the packet buffers.
  *
- * All regions need to be page-sized as we export them to
- * userspace through mmap. Only the latter need to be dma-able,
+ * All regions need to be multiple of a page size as we export them to
+ * userspace through mmap. Only the latter needs to be dma-able,
  * but for convenience use the same type of allocator for all.
  *
  * Once mapped, the three regions are exported to userspace
@@ -51,58 +51,97 @@
  * of the object, and from there locate the offset from the beginning
  * of the region.
  *
- * Allocator for a pool of memory objects of the same size.
+ * The invididual allocators manage a pool of memory for objects of
+ * the same size.
  * The pool is split into smaller clusters, whose size is a
  * multiple of the page size. The cluster size is chosen
  * to minimize the waste for a given max cluster size
  * (we do it by brute force, as we have relatively few object
  * per cluster).
  *
- * To be polite with the cache, objects are aligned to
- * the cache line, or 64 bytes. Sizes are rounded to multiple of 64.
- * For each object we have
- * one entry in the bitmap to signal the state. Allocation scans
- * the bitmap, but since this is done only on attach, we are not
+ * Objects are aligned to the cache line (64 bytes) rounding up object
+ * sizes when needed. A bitmap contains the state of each object.
+ * Allocation scans the bitmap; this is done only on attach, so we are not
  * too worried about performance
- */
-
-/*
- *	MEMORY SIZES:
  *
- * (all the parameters below will become tunables)
- *
- * struct netmap_if is variable size but small.
- * Assuming each NIC has 8+2 rings, (4+1 tx, 4+1 rx) the netmap_if
- * uses 120 bytes on a 64-bit machine.
- * We allocate NETMAP_IF_MAX_SIZE  (1024) which should work even for
- * cards with 48 ring pairs.
- * The total number of 'struct netmap_if' could be slightly larger
- * that the total number of rings on all interfaces on the system.
- */
-#define NETMAP_IF_MAX_SIZE      1024
-#define NETMAP_IF_MAX_NUM       512
-
-/*
- * netmap rings are up to 2..4k descriptors, 8 bytes each,
- * plus some glue at the beginning (32 bytes).
- * We set the default ring size to 9 pages (36K) and enable
- * a few hundreds of them.
+ * For each allocator we can define (thorugh sysctl) the size and
+ * number of each object. Memory is allocated at the first use of a
+ * netmap file descriptor, and can be freed when all such descriptors
+ * have been released (including unmapping the memory).
+ * If memory is scarce, the system tries to get as much as possible
+ * and the sysctl values reflect the actual allocation.
+ * Together with desired values, the sysctl export also absolute
+ * min and maximum values that cannot be overridden.
+ *
+ * struct netmap_if:
+ *	variable size, max 16 bytes per ring pair plus some fixed amount.
+ *	1024 bytes should be large enough in practice.
+ *
+ *	In the worst case we have one netmap_if per ring in the system.
+ *
+ * struct netmap_ring
+ *	variable too, 8 byte per slot plus some fixed amount.
+ *	Rings can be large (e.g. 4k slots, or >32Kbytes).
+ *	We default to 36 KB (9 pages), and a few hundred rings.
+ *
+ * struct netmap_buffer
+ *	The more the better, both because fast interfaces tend to have
+ *	many slots, and because we may want to use buffers to store
+ *	packets in userspace avoiding copies.
+ *	Must contain a full frame (eg 1518, or more for vlans, jumbo
+ *	frames etc.) plus be nicely aligned, plus some NICs restrict
+ *	the size to multiple of 1K or so. Default to 2K
  */
-#define NETMAP_RING_MAX_SIZE    (9*PAGE_SIZE)
-#define NETMAP_RING_MAX_NUM     200	/* approx 8MB */
 
-/*
- * Buffers: the more the better. Buffer size is NETMAP_BUF_SIZE,
- * 2k or slightly less, aligned to 64 bytes.
- * A large 10G interface can have 2k*18 = 36k buffers per interface,
- * or about 72MB of memory. Up to us to use more.
- */
 #ifndef CONSERVATIVE
-#define NETMAP_BUF_MAX_NUM      100000  /* 200MB */
+#define NETMAP_BUF_MAX_NUM	20*4096*2	/* large machine */
 #else /* CONSERVATIVE */
 #define NETMAP_BUF_MAX_NUM      20000   /* 40MB */
 #endif
 
+#ifdef linux
+#define NMA_LOCK_T		struct semaphore
+#define NMA_LOCK_INIT()		sema_init(&nm_mem.nm_mtx, 1)
+#define NMA_LOCK_DESTROY()	
+#define NMA_LOCK()		down(&nm_mem.nm_mtx)
+#define NMA_UNLOCK()		up(&nm_mem.nm_mtx)
+#else /* !linux */
+#define NMA_LOCK_T		struct mtx
+#define NMA_LOCK_INIT()		mtx_init(&nm_mem.nm_mtx, "netmap memory allocator lock", NULL, MTX_DEF)
+#define NMA_LOCK_DESTROY()	mtx_destroy(&nm_mem.nm_mtx)
+#define NMA_LOCK()		mtx_lock(&nm_mem.nm_mtx)
+#define NMA_UNLOCK()		mtx_unlock(&nm_mem.nm_mtx)
+#endif /* linux */
+
+enum {
+	NETMAP_IF_POOL   = 0,
+	NETMAP_RING_POOL,
+	NETMAP_BUF_POOL,
+	NETMAP_POOLS_NR
+};
+
+
+struct netmap_obj_params {
+	u_int size;
+	u_int num;
+};
+
+
+struct netmap_obj_params netmap_params[NETMAP_POOLS_NR] = {
+	[NETMAP_IF_POOL] = {
+		.size = 1024,
+		.num  = 100,
+	},
+	[NETMAP_RING_POOL] = {
+		.size = 9*PAGE_SIZE,
+		.num  = 200,
+	},
+	[NETMAP_BUF_POOL] = {
+		.size = 2048,
+		.num  = NETMAP_BUF_MAX_NUM,
+	},
+};
+
 
 struct netmap_obj_pool {
 	char name[16];		/* name of the allocator */
@@ -110,6 +149,12 @@
 	u_int objfree;          /* number of free objects. */
 	u_int clustentries;	/* actual objects per cluster */
 
+	/* limits */
+	u_int objminsize;	/* minimum object size */
+	u_int objmaxsize;	/* maximum object size */
+	u_int nummin;		/* minimum number of objects */
+	u_int nummax;		/* maximum number of objects */
+
 	/* the total memory space is _numclusters*_clustsize */
 	u_int _numclusters;	/* how many clusters */
 	u_int _clustsize;        /* cluster size */
@@ -118,20 +163,69 @@
 	u_int _memtotal;	/* _numclusters*_clustsize */
 	struct lut_entry *lut;  /* virt,phys addresses, objtotal entries */
 	uint32_t *bitmap;       /* one bit per buffer, 1 means free */
+	uint32_t bitmap_slots;	/* number of uint32 entries in bitmap */
 };
 
+
 struct netmap_mem_d {
-	NM_LOCK_T nm_mtx; /* protect the allocator ? */
+	NMA_LOCK_T nm_mtx;  /* protect the allocator */
 	u_int nm_totalsize; /* shorthand */
 
-	/* pointers to the three allocators */
-	struct netmap_obj_pool *nm_if_pool;
-	struct netmap_obj_pool *nm_ring_pool;
-	struct netmap_obj_pool *nm_buf_pool;
+	int finalized;		/* !=0 iff preallocation done */
+	int lasterr;		/* last error for curr config */
+	int refcount;		/* existing priv structures */
+	/* the three allocators */
+	struct netmap_obj_pool pools[NETMAP_POOLS_NR];
+};
+
+
+static struct netmap_mem_d nm_mem = {	/* Our memory allocator. */
+	.pools = {
+		[NETMAP_IF_POOL] = {
+			.name 	= "netmap_if",
+			.objminsize = sizeof(struct netmap_if),
+			.objmaxsize = 4096,
+			.nummin     = 10,	/* don't be stingy */
+			.nummax	    = 10000,	/* XXX very large */
+		},
+		[NETMAP_RING_POOL] = {
+			.name 	= "netmap_ring",
+			.objminsize = sizeof(struct netmap_ring),
+			.objmaxsize = 32*PAGE_SIZE,
+			.nummin     = 2,
+			.nummax	    = 1024,
+		},
+		[NETMAP_BUF_POOL] = {
+			.name	= "netmap_buf",
+			.objminsize = 64,
+			.objmaxsize = 65536,
+			.nummin     = 4,
+			.nummax	    = 1000000, /* one million! */
+		},
+	},
 };
 
 struct lut_entry *netmap_buffer_lut;	/* exported */
 
+/* memory allocator related sysctls */
+
+#define STRINGIFY(x) #x
+
+#define DECLARE_SYSCTLS(id, name) \
+	/* TUNABLE_INT("hw.netmap." STRINGIFY(name) "_size", &netmap_params[id].size); */ \
+	SYSCTL_INT(_dev_netmap, OID_AUTO, name##_size, \
+	    CTLFLAG_RW, &netmap_params[id].size, 0, "Requested size of netmap " STRINGIFY(name) "s"); \
+        SYSCTL_INT(_dev_netmap, OID_AUTO, name##_curr_size, \
+            CTLFLAG_RD, &nm_mem.pools[id]._objsize, 0, "Current size of netmap " STRINGIFY(name) "s"); \
+	/* TUNABLE_INT("hw.netmap." STRINGIFY(name) "_num", &netmap_params[id].num); */ \
+        SYSCTL_INT(_dev_netmap, OID_AUTO, name##_num, \
+            CTLFLAG_RW, &netmap_params[id].num, 0, "Requested number of netmap " STRINGIFY(name) "s"); \
+        SYSCTL_INT(_dev_netmap, OID_AUTO, name##_curr_num, \
+            CTLFLAG_RD, &nm_mem.pools[id].objtotal, 0, "Current number of netmap " STRINGIFY(name) "s")
+
+DECLARE_SYSCTLS(NETMAP_IF_POOL, if);
+DECLARE_SYSCTLS(NETMAP_RING_POOL, ring);
+DECLARE_SYSCTLS(NETMAP_BUF_POOL, buf);
 
 /*
  * Convert a userspace offset to a phisical address.
@@ -146,24 +240,25 @@
 static inline vm_paddr_t
 netmap_ofstophys(vm_offset_t offset)
 {
-	const struct netmap_obj_pool *p[] = {
-		nm_mem->nm_if_pool,
-		nm_mem->nm_ring_pool,
-		nm_mem->nm_buf_pool };
 	int i;
 	vm_offset_t o = offset;
+	struct netmap_obj_pool *p = nm_mem.pools;
 
-
-	for (i = 0; i < 3; offset -= p[i]->_memtotal, i++) {
-		if (offset >= p[i]->_memtotal)
+	for (i = 0; i < NETMAP_POOLS_NR; offset -= p[i]._memtotal, i++) {
+		if (offset >= p[i]._memtotal)
 			continue;
 		// XXX now scan the clusters
-		return p[i]->lut[offset / p[i]->_objsize].paddr +
-			offset % p[i]->_objsize;
+		return p[i].lut[offset / p[i]._objsize].paddr +
+			offset % p[i]._objsize;
 	}
+	/* this is only in case of errors */
 	D("invalid ofs 0x%x out of 0x%x 0x%x 0x%x", (u_int)o,
-		p[0]->_memtotal, p[0]->_memtotal + p[1]->_memtotal,
-		p[0]->_memtotal + p[1]->_memtotal + p[2]->_memtotal);
+		p[NETMAP_IF_POOL]._memtotal,
+		p[NETMAP_IF_POOL]._memtotal
+			+ p[NETMAP_RING_POOL]._memtotal,
+		p[NETMAP_IF_POOL]._memtotal
+			+ p[NETMAP_RING_POOL]._memtotal
+			+ p[NETMAP_BUF_POOL]._memtotal);
 	return 0;	// XXX bad address
 }
 
@@ -198,20 +293,24 @@
 
 /* Helper functions which convert virtual addresses to offsets */
 #define netmap_if_offset(v)					\
-	netmap_obj_offset(nm_mem->nm_if_pool, (v))
+	netmap_obj_offset(&nm_mem.pools[NETMAP_IF_POOL], (v))
 
 #define netmap_ring_offset(v)					\
-    (nm_mem->nm_if_pool->_memtotal + 				\
-	netmap_obj_offset(nm_mem->nm_ring_pool, (v)))
+    (nm_mem.pools[NETMAP_IF_POOL]._memtotal + 				\
+	netmap_obj_offset(&nm_mem.pools[NETMAP_RING_POOL], (v)))
 
 #define netmap_buf_offset(v)					\
-    (nm_mem->nm_if_pool->_memtotal +				\
-	nm_mem->nm_ring_pool->_memtotal +			\
-	netmap_obj_offset(nm_mem->nm_buf_pool, (v)))
+    (nm_mem.pools[NETMAP_IF_POOL]._memtotal +				\
+	nm_mem.pools[NETMAP_RING_POOL]._memtotal +			\
+	netmap_obj_offset(&nm_mem.pools[NETMAP_BUF_POOL], (v)))
 
 
+/*
+ * report the index, and use start position as a hint,
+ * otherwise buffer allocation becomes terribly expensive.
+ */
 static void *
-netmap_obj_malloc(struct netmap_obj_pool *p, int len)
+netmap_obj_malloc(struct netmap_obj_pool *p, int len, uint32_t *start, uint32_t *index)
 {
 	uint32_t i = 0;			/* index in the bitmap */
 	uint32_t mask, j;		/* slot counter */
@@ -227,9 +326,11 @@
 		D("%s allocator: run out of memory", p->name);
 		return NULL;
 	}
+	if (start)
+		i = *start;
 
-	/* termination is guaranteed by p->free */
-	while (vaddr == NULL) {
+	/* termination is guaranteed by p->free, but better check bounds on i */
+	while (vaddr == NULL && i < p->bitmap_slots)  {
 		uint32_t cur = p->bitmap[i];
 		if (cur == 0) { /* bitmask is fully used */
 			i++;
@@ -243,9 +344,13 @@
 		p->objfree--;
 
 		vaddr = p->lut[i * 32 + j].vaddr;
+		if (index)
+			*index = i * 32 + j;
 	}
 	ND("%s allocator: allocated object @ [%d][%d]: vaddr %p", i, j, vaddr);
 
+	if (start)
+		*start = i;
 	return vaddr;
 }
 
@@ -287,71 +392,78 @@
 	    vaddr, p->name);
 }
 
-#define netmap_if_malloc(len)	netmap_obj_malloc(nm_mem->nm_if_pool, len)
-#define netmap_if_free(v)	netmap_obj_free_va(nm_mem->nm_if_pool, (v))
-#define netmap_ring_malloc(len)	netmap_obj_malloc(nm_mem->nm_ring_pool, len)
-#define netmap_buf_malloc()			\
-	netmap_obj_malloc(nm_mem->nm_buf_pool, NETMAP_BUF_SIZE)
+#define netmap_if_malloc(len)	netmap_obj_malloc(&nm_mem.pools[NETMAP_IF_POOL], len, NULL, NULL)
+#define netmap_if_free(v)	netmap_obj_free_va(&nm_mem.pools[NETMAP_IF_POOL], (v))
+#define netmap_ring_malloc(len)	netmap_obj_malloc(&nm_mem.pools[NETMAP_RING_POOL], len, NULL, NULL)
+#define netmap_ring_free(v)	netmap_obj_free_va(&nm_mem.pools[NETMAP_RING_POOL], (v))
+#define netmap_buf_malloc(_pos, _index)			\
+	netmap_obj_malloc(&nm_mem.pools[NETMAP_BUF_POOL], NETMAP_BUF_SIZE, _pos, _index)
 
 
 /* Return the index associated to the given packet buffer */
 #define netmap_buf_index(v)						\
-    (netmap_obj_offset(nm_mem->nm_buf_pool, (v)) / nm_mem->nm_buf_pool->_objsize)
+    (netmap_obj_offset(&nm_mem.pools[NETMAP_BUF_POOL], (v)) / nm_mem.pools[NETMAP_BUF_POOL]._objsize)
 
 
-static void
-netmap_new_bufs(struct netmap_if *nifp __unused,
+/* Return nonzero on error */
+static int
+netmap_new_bufs(struct netmap_if *nifp,
                 struct netmap_slot *slot, u_int n)
 {
-	struct netmap_obj_pool *p = nm_mem->nm_buf_pool;
-	uint32_t i = 0;	/* slot counter */
+	struct netmap_obj_pool *p = &nm_mem.pools[NETMAP_BUF_POOL];
+	int i = 0;	/* slot counter */
+	uint32_t pos = 0;	/* slot in p->bitmap */
+	uint32_t index = 0;	/* buffer index */
 
+	(void)nifp;	/* UNUSED */
 	for (i = 0; i < n; i++) {
-		void *vaddr = netmap_buf_malloc();
+		void *vaddr = netmap_buf_malloc(&pos, &index);
 		if (vaddr == NULL) {
 			D("unable to locate empty packet buffer");
 			goto cleanup;
 		}
-
-		slot[i].buf_idx = netmap_buf_index(vaddr);
-		KASSERT(slot[i].buf_idx != 0,
-		    ("Assigning buf_idx=0 to just created slot"));
+		slot[i].buf_idx = index;
 		slot[i].len = p->_objsize;
-		slot[i].flags = NS_BUF_CHANGED; // XXX GAETANO hack
+		/* XXX setting flags=NS_BUF_CHANGED forces a pointer reload
+		 * in the NIC ring. This is a hack that hides missing
+		 * initializations in the drivers, and should go away.
+		 */
+		slot[i].flags = NS_BUF_CHANGED;
 	}
 
-	ND("allocated %d buffers, %d available", n, p->objfree);
-	return;
+	ND("allocated %d buffers, %d available, first at %d", n, p->objfree, pos);
+	return (0);
 
 cleanup:
-	for (i--; i >= 0; i--) {
-		netmap_obj_free(nm_mem->nm_buf_pool, slot[i].buf_idx);
+	while (i > 0) {
+		i--;
+		netmap_obj_free(p, slot[i].buf_idx);
 	}
+	bzero(slot, n * sizeof(slot[0]));
+	return (ENOMEM);
 }
 
 
 static void
 netmap_free_buf(struct netmap_if *nifp, uint32_t i)
 {
-	struct netmap_obj_pool *p = nm_mem->nm_buf_pool;
+	struct netmap_obj_pool *p = &nm_mem.pools[NETMAP_BUF_POOL];
+
 	if (i < 2 || i >= p->objtotal) {
 		D("Cannot free buf#%d: should be in [2, %d[", i, p->objtotal);
 		return;
 	}
-	netmap_obj_free(nm_mem->nm_buf_pool, i);
+	netmap_obj_free(p, i);
 }
 
-
-/*
- * Free all resources related to an allocator.
- */
 static void
-netmap_destroy_obj_allocator(struct netmap_obj_pool *p)
+netmap_reset_obj_allocator(struct netmap_obj_pool *p)
 {
 	if (p == NULL)
 		return;
 	if (p->bitmap)
 		free(p->bitmap, M_NETMAP);
+	p->bitmap = NULL;
 	if (p->lut) {
 		int i;
 		for (i = 0; i < p->objtotal; i += p->clustentries) {
@@ -359,10 +471,24 @@
 				contigfree(p->lut[i].vaddr, p->_clustsize, M_NETMAP);
 		}
 		bzero(p->lut, sizeof(struct lut_entry) * p->objtotal);
+#ifdef linux
+		vfree(p->lut);
+#else
 		free(p->lut, M_NETMAP);
+#endif
 	}
-	bzero(p, sizeof(*p));
-	free(p, M_NETMAP);
+	p->lut = NULL;
+}
+
+/*
+ * Free all resources related to an allocator.
+ */
+static void
+netmap_destroy_obj_allocator(struct netmap_obj_pool *p)
+{
+	if (p == NULL)
+		return;
+	netmap_reset_obj_allocator(p);
 }
 
 /*
@@ -376,10 +502,12 @@
  * XXX note -- userspace needs the buffers to be contiguous,
  *	so we cannot afford gaps at the end of a cluster.
  */
-static struct netmap_obj_pool *
-netmap_new_obj_allocator(const char *name, u_int objtotal, u_int objsize)
+
+
+/* call with NMA_LOCK held */
+static int
+netmap_config_obj_allocator(struct netmap_obj_pool *p, u_int objtotal, u_int objsize)
 {
-	struct netmap_obj_pool *p;
 	int i, n;
 	u_int clustsize;	/* the cluster size, multiple of page size */
 	u_int clustentries;	/* how many objects per entry */
@@ -389,7 +517,7 @@
 	if (objsize >= MAX_CLUSTSIZE) {
 		/* we could do it but there is no point */
 		D("unsupported allocation for %d bytes", objsize);
-		return NULL;
+		goto error;
 	}
 	/* make sure objsize is a multiple of LINE_ROUND */
 	i = (objsize & (LINE_ROUND - 1));
@@ -397,6 +525,16 @@
 		D("XXX aligning object by %d bytes", LINE_ROUND - i);
 		objsize += LINE_ROUND - i;
 	}
+	if (objsize < p->objminsize || objsize > p->objmaxsize) {
+		D("requested objsize %d out of range [%d, %d]", 
+			objsize, p->objminsize, p->objmaxsize);
+		goto error;
+	}
+	if (objtotal < p->nummin || objtotal > p->nummax) {
+		D("requested objtotal %d out of range [%d, %d]", 
+			objtotal, p->nummin, p->nummax);
+		goto error;
+	}
 	/*
 	 * Compute number of objects using a brute-force approach:
 	 * given a max cluster size,
@@ -424,74 +562,87 @@
 	D("objsize %d clustsize %d objects %d",
 		objsize, clustsize, clustentries);
 
-	p = malloc(sizeof(struct netmap_obj_pool), M_NETMAP,
-	    M_WAITOK | M_ZERO);
-	if (p == NULL) {
-		D("Unable to create '%s' allocator", name);
-		return NULL;
-	}
 	/*
-	 * Allocate and initialize the lookup table.
-	 *
 	 * The number of clusters is n = ceil(objtotal/clustentries)
 	 * objtotal' = n * clustentries
 	 */
-	strncpy(p->name, name, sizeof(p->name));
 	p->clustentries = clustentries;
 	p->_clustsize = clustsize;
 	n = (objtotal + clustentries - 1) / clustentries;
 	p->_numclusters = n;
 	p->objtotal = n * clustentries;
 	p->objfree = p->objtotal - 2; /* obj 0 and 1 are reserved */
-	p->_objsize = objsize;
 	p->_memtotal = p->_numclusters * p->_clustsize;
+	p->_objsize = objsize;
+
+	return 0;
+
+error:
+	p->_objsize = objsize;
+	p->objtotal = objtotal;
+
+	return EINVAL;
+}
 
-	p->lut = malloc(sizeof(struct lut_entry) * p->objtotal,
-	    M_NETMAP, M_WAITOK | M_ZERO);
+
+/* call with NMA_LOCK held */
+static int
+netmap_finalize_obj_allocator(struct netmap_obj_pool *p)
+{
+	int i, n;
+
+	n = sizeof(struct lut_entry) * p->objtotal;
+#ifdef linux
+	p->lut = vmalloc(n);
+#else
+	p->lut = malloc(n, M_NETMAP, M_NOWAIT | M_ZERO);
+#endif
 	if (p->lut == NULL) {
-		D("Unable to create lookup table for '%s' allocator", name);
+		D("Unable to create lookup table (%d bytes) for '%s'", n, p->name);
 		goto clean;
 	}
 
 	/* Allocate the bitmap */
 	n = (p->objtotal + 31) / 32;
-	p->bitmap = malloc(sizeof(uint32_t) * n, M_NETMAP, M_WAITOK | M_ZERO);
+	p->bitmap = malloc(sizeof(uint32_t) * n, M_NETMAP, M_NOWAIT | M_ZERO);
 	if (p->bitmap == NULL) {
 		D("Unable to create bitmap (%d entries) for allocator '%s'", n,
-		    name);
+		    p->name);
 		goto clean;
 	}
+	p->bitmap_slots = n;
 
 	/*
 	 * Allocate clusters, init pointers and bitmap
 	 */
 	for (i = 0; i < p->objtotal;) {
-		int lim = i + clustentries;
+		int lim = i + p->clustentries;
 		char *clust;
 
-		clust = contigmalloc(clustsize, M_NETMAP, M_WAITOK | M_ZERO,
+		clust = contigmalloc(p->_clustsize, M_NETMAP, M_NOWAIT | M_ZERO,
 		    0, -1UL, PAGE_SIZE, 0);
 		if (clust == NULL) {
 			/*
 			 * If we get here, there is a severe memory shortage,
 			 * so halve the allocated memory to reclaim some.
+			 * XXX check boundaries
 			 */
 			D("Unable to create cluster at %d for '%s' allocator",
-			    i, name);
+			    i, p->name);
 			lim = i / 2;
-			for (; i >= lim; i--) {
+			for (i--; i >= lim; i--) {
 				p->bitmap[ (i>>5) ] &=  ~( 1 << (i & 31) );
-				if (i % clustentries == 0 && p->lut[i].vaddr)
+				if (i % p->clustentries == 0 && p->lut[i].vaddr)
 					contigfree(p->lut[i].vaddr,
 						p->_clustsize, M_NETMAP);
 			}
 			p->objtotal = i;
 			p->objfree = p->objtotal - 2;
-			p->_numclusters = i / clustentries;
+			p->_numclusters = i / p->clustentries;
 			p->_memtotal = p->_numclusters * p->_clustsize;
 			break;
 		}
-		for (; i < lim; i++, clust += objsize) {
+		for (; i < lim; i++, clust += p->_objsize) {
 			p->bitmap[ (i>>5) ] |=  ( 1 << (i & 31) );
 			p->lut[i].vaddr = clust;
 			p->lut[i].paddr = vtophys(clust);
@@ -500,83 +651,164 @@
 	p->bitmap[0] = ~3; /* objs 0 and 1 is always busy */
 	D("Pre-allocated %d clusters (%d/%dKB) for '%s'",
 	    p->_numclusters, p->_clustsize >> 10,
-	    p->_memtotal >> 10, name);
+	    p->_memtotal >> 10, p->name);
 
-	return p;
+	return 0;
 
 clean:
-	netmap_destroy_obj_allocator(p);
-	return NULL;
+	netmap_reset_obj_allocator(p);
+	return ENOMEM;
 }
 
+/* call with lock held */
 static int
-netmap_memory_init(void)
+netmap_memory_config_changed(void)
 {
-	struct netmap_obj_pool *p;
+	int i;
 
-	nm_mem = malloc(sizeof(struct netmap_mem_d), M_NETMAP,
-			      M_WAITOK | M_ZERO);
-	if (nm_mem == NULL)
-		goto clean;
+	for (i = 0; i < NETMAP_POOLS_NR; i++) {
+		if (nm_mem.pools[i]._objsize != netmap_params[i].size ||
+		    nm_mem.pools[i].objtotal != netmap_params[i].num)
+		    return 1;
+	}
+	return 0;
+}
 
-	p = netmap_new_obj_allocator("netmap_if",
-	    NETMAP_IF_MAX_NUM, NETMAP_IF_MAX_SIZE);
-	if (p == NULL)
-		goto clean;
-	nm_mem->nm_if_pool = p;
 
-	p = netmap_new_obj_allocator("netmap_ring",
-	    NETMAP_RING_MAX_NUM, NETMAP_RING_MAX_SIZE);
-	if (p == NULL)
-		goto clean;
-	nm_mem->nm_ring_pool = p;
+/* call with lock held */
+static int
+netmap_memory_config(void)
+{
+	int i;
 
-	p = netmap_new_obj_allocator("netmap_buf",
-	    NETMAP_BUF_MAX_NUM, NETMAP_BUF_SIZE);
-	if (p == NULL)
-		goto clean;
-	netmap_total_buffers = p->objtotal;
-	netmap_buffer_lut = p->lut;
-	nm_mem->nm_buf_pool = p;
-	netmap_buffer_base = p->lut[0].vaddr;
-
-	mtx_init(&nm_mem->nm_mtx, "netmap memory allocator lock", NULL,
-		 MTX_DEF);
-	nm_mem->nm_totalsize =
-	    nm_mem->nm_if_pool->_memtotal +
-	    nm_mem->nm_ring_pool->_memtotal +
-	    nm_mem->nm_buf_pool->_memtotal;
+
+	if (!netmap_memory_config_changed())
+		goto out;
+
+	D("reconfiguring");
+
+	if (nm_mem.finalized) {
+		/* reset previous allocation */
+		for (i = 0; i < NETMAP_POOLS_NR; i++) {
+			netmap_reset_obj_allocator(&nm_mem.pools[i]);
+		}    
+		nm_mem.finalized = 0;
+        }
+
+	for (i = 0; i < NETMAP_POOLS_NR; i++) {
+		nm_mem.lasterr = netmap_config_obj_allocator(&nm_mem.pools[i],
+				netmap_params[i].num, netmap_params[i].size);
+		if (nm_mem.lasterr)
+			goto out;
+	}
 
 	D("Have %d KB for interfaces, %d KB for rings and %d MB for buffers",
-	    nm_mem->nm_if_pool->_memtotal >> 10,
-	    nm_mem->nm_ring_pool->_memtotal >> 10,
-	    nm_mem->nm_buf_pool->_memtotal >> 20);
-	return 0;
+	    nm_mem.pools[NETMAP_IF_POOL]._memtotal >> 10,
+	    nm_mem.pools[NETMAP_RING_POOL]._memtotal >> 10,
+	    nm_mem.pools[NETMAP_BUF_POOL]._memtotal >> 20);
 
-clean:
-	if (nm_mem) {
-		netmap_destroy_obj_allocator(nm_mem->nm_ring_pool);
-		netmap_destroy_obj_allocator(nm_mem->nm_if_pool);
-		free(nm_mem, M_NETMAP);
+out:
+
+	return nm_mem.lasterr;
+}
+
+/* call with lock held */
+static int
+netmap_memory_finalize(void)
+{
+	int i;
+	u_int totalsize = 0;
+
+	nm_mem.refcount++;
+	if (nm_mem.refcount > 1) {
+		D("busy (refcount %d)", nm_mem.refcount);
+		goto out;
 	}
-	return ENOMEM;
+
+	/* update configuration if changed */
+	if (netmap_memory_config())
+		goto out;
+
+	if (nm_mem.finalized) {
+		/* may happen if config is not changed */
+		ND("nothing to do");
+		goto out;
+	}
+
+	for (i = 0; i < NETMAP_POOLS_NR; i++) {
+		nm_mem.lasterr = netmap_finalize_obj_allocator(&nm_mem.pools[i]);
+		if (nm_mem.lasterr)
+			goto cleanup;
+		totalsize += nm_mem.pools[i]._memtotal;
+	}
+	nm_mem.nm_totalsize = totalsize;
+
+	/* backward compatibility */
+	netmap_buf_size = nm_mem.pools[NETMAP_BUF_POOL]._objsize;
+	netmap_total_buffers = nm_mem.pools[NETMAP_BUF_POOL].objtotal;
+
+	netmap_buffer_lut = nm_mem.pools[NETMAP_BUF_POOL].lut;
+	netmap_buffer_base = nm_mem.pools[NETMAP_BUF_POOL].lut[0].vaddr;
+
+	nm_mem.finalized = 1;
+	nm_mem.lasterr = 0;
+
+	/* make sysctl values match actual values in the pools */
+	for (i = 0; i < NETMAP_POOLS_NR; i++) {
+		netmap_params[i].size = nm_mem.pools[i]._objsize;
+		netmap_params[i].num  = nm_mem.pools[i].objtotal;
+	}
+
+out:
+	if (nm_mem.lasterr)
+		nm_mem.refcount--;
+
+	return nm_mem.lasterr;
+
+cleanup:
+	for (i = 0; i < NETMAP_POOLS_NR; i++) {
+		netmap_reset_obj_allocator(&nm_mem.pools[i]);
+	}
+	nm_mem.refcount--;
+
+	return nm_mem.lasterr;
 }
 
+static int
+netmap_memory_init(void)
+{
+	NMA_LOCK_INIT();
+	return (0);
+}
 
 static void
 netmap_memory_fini(void)
 {
-	if (!nm_mem)
-		return;
-	netmap_destroy_obj_allocator(nm_mem->nm_if_pool);
-	netmap_destroy_obj_allocator(nm_mem->nm_ring_pool);
-	netmap_destroy_obj_allocator(nm_mem->nm_buf_pool);
-	mtx_destroy(&nm_mem->nm_mtx);
-	free(nm_mem, M_NETMAP);
+	int i;
+
+	for (i = 0; i < NETMAP_POOLS_NR; i++) {
+	    netmap_destroy_obj_allocator(&nm_mem.pools[i]);
+	}
+	NMA_LOCK_DESTROY();
 }
 
+static void
+netmap_free_rings(struct netmap_adapter *na)
+{
+	int i;
+	for (i = 0; i < na->num_tx_rings + 1; i++) {
+		netmap_ring_free(na->tx_rings[i].ring);
+		na->tx_rings[i].ring = NULL;
+	}
+	for (i = 0; i < na->num_rx_rings + 1; i++) {
+		netmap_ring_free(na->rx_rings[i].ring);
+		na->rx_rings[i].ring = NULL;
+	}
+}
 
 
+
+/* call with NMA_LOCK held */
 static void *
 netmap_if_new(const char *ifname, struct netmap_adapter *na)
 {
@@ -588,7 +820,6 @@
 	u_int nrx = na->num_rx_rings + 1; /* shorthand, include stack ring */
 	struct netmap_kring *kring;
 
-	NMA_LOCK();
 	/*
 	 * the descriptor is followed inline by an array of offsets
 	 * to the tx and rx rings in the shared memory region.
@@ -596,7 +827,6 @@
 	len = sizeof(struct netmap_if) + (nrx + ntx) * sizeof(ssize_t);
 	nifp = netmap_if_malloc(len);
 	if (nifp == NULL) {
-		NMA_UNLOCK();
 		return NULL;
 	}
 
@@ -607,7 +837,6 @@
 
 	(na->refcount)++;	/* XXX atomic ? we are under lock */
 	if (na->refcount > 1) { /* already setup, we are done */
-		NMA_UNLOCK();
 		goto final;
 	}
 
@@ -631,8 +860,8 @@
 		kring->ring = ring;
 		*(int *)(uintptr_t)&ring->num_slots = kring->nkr_num_slots = ndesc;
 		*(ssize_t *)(uintptr_t)&ring->buf_ofs =
-		    (nm_mem->nm_if_pool->_memtotal +
-			nm_mem->nm_ring_pool->_memtotal) -
+		    (nm_mem.pools[NETMAP_IF_POOL]._memtotal +
+			nm_mem.pools[NETMAP_RING_POOL]._memtotal) -
 			netmap_ring_offset(ring);
 
 		/*
@@ -645,7 +874,10 @@
 		ring->cur = kring->nr_hwcur = 0;
 		*(int *)(uintptr_t)&ring->nr_buf_size = NETMAP_BUF_SIZE;
 		ND("initializing slots for txring[%d]", i);
-		netmap_new_bufs(nifp, ring->slot, ndesc);
+		if (netmap_new_bufs(nifp, ring->slot, ndesc)) {
+			D("Cannot allocate buffers for tx_ring[%d] for %s", i, ifname);
+			goto cleanup;
+		}
 	}
 
 	for (i = 0; i < nrx; i++) { /* Receive rings */
@@ -665,25 +897,27 @@
 		kring->ring = ring;
 		*(int *)(uintptr_t)&ring->num_slots = kring->nkr_num_slots = ndesc;
 		*(ssize_t *)(uintptr_t)&ring->buf_ofs =
-		    (nm_mem->nm_if_pool->_memtotal +
-		        nm_mem->nm_ring_pool->_memtotal) -
+		    (nm_mem.pools[NETMAP_IF_POOL]._memtotal +
+		        nm_mem.pools[NETMAP_RING_POOL]._memtotal) -
 			netmap_ring_offset(ring);
 
 		ring->cur = kring->nr_hwcur = 0;
 		ring->avail = kring->nr_hwavail = 0; /* empty */
 		*(int *)(uintptr_t)&ring->nr_buf_size = NETMAP_BUF_SIZE;
 		ND("initializing slots for rxring[%d]", i);
-		netmap_new_bufs(nifp, ring->slot, ndesc);
+		if (netmap_new_bufs(nifp, ring->slot, ndesc)) {
+			D("Cannot allocate buffers for rx_ring[%d] for %s", i, ifname);
+			goto cleanup;
+		}
 	}
-	NMA_UNLOCK();
 #ifdef linux
 	// XXX initialize the selrecord structs.
 	for (i = 0; i < ntx; i++)
-		init_waitqueue_head(&na->rx_rings[i].si);
-	for (i = 0; i < nrx; i++)
 		init_waitqueue_head(&na->tx_rings[i].si);
-	init_waitqueue_head(&na->rx_si);
+	for (i = 0; i < nrx; i++)
+		init_waitqueue_head(&na->rx_rings[i].si);
 	init_waitqueue_head(&na->tx_si);
+	init_waitqueue_head(&na->rx_si);
 #endif
 final:
 	/*
@@ -702,19 +936,16 @@
 	}
 	return (nifp);
 cleanup:
-	// XXX missing
-	NMA_UNLOCK();
+	netmap_free_rings(na);
+	netmap_if_free(nifp);
+	(na->refcount)--;
 	return NULL;
 }
 
+/* call with NMA_LOCK held */
 static void
-netmap_free_rings(struct netmap_adapter *na)
+netmap_memory_deref(void)
 {
-	int i;
-	for (i = 0; i < na->num_tx_rings + 1; i++)
-		netmap_obj_free_va(nm_mem->nm_ring_pool,
-			na->tx_rings[i].ring);
-	for (i = 0; i < na->num_rx_rings + 1; i++)
-		netmap_obj_free_va(nm_mem->nm_ring_pool,
-			na->rx_rings[i].ring);
+	nm_mem.refcount--;
+	D("refcount = %d", nm_mem.refcount);
 }
--- sys/net/netmap_user.h.orig	2013-01-09 01:44:36.000000000 +0100
+++ sys/net/netmap_user.h	2013-01-09 01:44:38.000000000 +0100
@@ -31,7 +31,7 @@
  */
 
 /*
- * $FreeBSD: releng/9.1/sys/net/netmap_user.h 235549 2012-05-17 15:02:51Z luigi $
+ * $FreeBSD: head/sys/net/netmap_user.h 241166 2012-10-03 21:41:20Z emaste $
  * $Id: netmap_user.h 10597 2012-02-21 05:08:32Z luigi $
  *
  * This header contains the macros used to manipulate netmap structures
@@ -62,15 +62,16 @@
 #ifndef _NET_NETMAP_USER_H_
 #define _NET_NETMAP_USER_H_
 
-#define NETMAP_IF(b, o)	(struct netmap_if *)((char *)(b) + (o))
+#define _NETMAP_OFFSET(type, ptr, offset) \
+	((type)(void *)((char *)(ptr) + (offset)))
 
-#define NETMAP_TXRING(nifp, index)			\
-	((struct netmap_ring *)((char *)(nifp) +	\
-		(nifp)->ring_ofs[index] ) )
-
-#define NETMAP_RXRING(nifp, index)			\
-	((struct netmap_ring *)((char *)(nifp) +	\
-	    (nifp)->ring_ofs[index + (nifp)->ni_tx_rings + 1] ) )
+#define NETMAP_IF(b, o)	_NETMAP_OFFSET(struct netmap_if *, b, o)
+
+#define NETMAP_TXRING(nifp, index) _NETMAP_OFFSET(struct netmap_ring *, \
+	nifp, (nifp)->ring_ofs[index] )
+
+#define NETMAP_RXRING(nifp, index) _NETMAP_OFFSET(struct netmap_ring *,	\
+	nifp, (nifp)->ring_ofs[index + (nifp)->ni_tx_rings + 1] )
 
 #define NETMAP_BUF(ring, index)				\
 	((char *)(ring) + (ring)->buf_ofs + ((index)*(ring)->nr_buf_size))
diff -ruN tools/tools/netmap.orig/Makefile tools/tools/netmap/Makefile
--- tools/tools/netmap.orig/Makefile	2013-01-09 01:54:33.000000000 +0100
+++ tools/tools/netmap/Makefile	2013-01-09 01:54:41.000000000 +0100
@@ -1,5 +1,5 @@
 #
-# $FreeBSD: releng/9.1/tools/tools/netmap/Makefile 231650 2012-02-14 09:42:02Z luigi $
+# $FreeBSD: head/tools/tools/netmap/Makefile 227614 2011-11-17 12:17:39Z luigi $
 #
 # For multiple programs using a single source file each,
 # we can just define 'progs' and create custom targets.
diff -ruN tools/tools/netmap.orig/README tools/tools/netmap/README
--- tools/tools/netmap.orig/README	2013-01-09 01:54:33.000000000 +0100
+++ tools/tools/netmap/README	2013-01-09 01:54:41.000000000 +0100
@@ -1,4 +1,4 @@
-$FreeBSD: releng/9.1/tools/tools/netmap/README 235549 2012-05-17 15:02:51Z luigi $
+$FreeBSD: head/tools/tools/netmap/README 234975 2012-05-03 17:08:40Z luigi $
 
 This directory contains examples that use netmap
 
diff -ruN tools/tools/netmap.orig/bridge.c tools/tools/netmap/bridge.c
--- tools/tools/netmap.orig/bridge.c	2013-01-09 01:54:33.000000000 +0100
+++ tools/tools/netmap/bridge.c	2013-01-09 01:54:41.000000000 +0100
@@ -6,7 +6,7 @@
  * A netmap client to bridge two network interfaces
  * (or one interface and the host stack).
  *
- * $FreeBSD: releng/9.1/tools/tools/netmap/bridge.c 235549 2012-05-17 15:02:51Z luigi $
+ * $FreeBSD: head/tools/tools/netmap/bridge.c 237729 2012-06-28 20:10:43Z emaste $
  */
 
 #include <errno.h>
@@ -79,7 +79,7 @@
 
 
 static int
-do_ioctl(struct my_ring *me, int what)
+do_ioctl(struct my_ring *me, unsigned long what)
 {
 	struct ifreq ifr;
 	int error;
@@ -98,7 +98,7 @@
 	}
 	error = ioctl(me->fd, what, &ifr);
 	if (error) {
-		D("ioctl error %d", what);
+		D("ioctl error 0x%lx", what);
 		return error;
 	}
 	switch (what) {
diff -ruN tools/tools/netmap.orig/click-test.cfg tools/tools/netmap/click-test.cfg
--- tools/tools/netmap.orig/click-test.cfg	2013-01-09 01:54:33.000000000 +0100
+++ tools/tools/netmap/click-test.cfg	2013-01-09 01:54:41.000000000 +0100
@@ -1,5 +1,5 @@
 //
-// $FreeBSD: releng/9.1/tools/tools/netmap/click-test.cfg 231650 2012-02-14 09:42:02Z luigi $
+// $FreeBSD: head/tools/tools/netmap/click-test.cfg 227614 2011-11-17 12:17:39Z luigi $
 //
 // A sample test configuration for click
 //
diff -ruN tools/tools/netmap.orig/pcap.c tools/tools/netmap/pcap.c
--- tools/tools/netmap.orig/pcap.c	2013-01-09 01:54:33.000000000 +0100
+++ tools/tools/netmap/pcap.c	2013-01-09 01:54:41.000000000 +0100
@@ -7,7 +7,7 @@
  * This is not 100% complete but enough to let tcpdump, trafshow
  * and other apps work.
  *
- * $FreeBSD: releng/9.1/tools/tools/netmap/pcap.c 235549 2012-05-17 15:02:51Z luigi $
+ * $FreeBSD: head/tools/tools/netmap/pcap.c 241464 2012-10-11 21:24:07Z emaste $
  */
 
 #include <errno.h>
@@ -38,7 +38,7 @@
 
 #define MIN(a, b) ((a) < (b) ? (a) : (b))
 
-char *version = "$Id$";
+const char *version = "$Id$";
 int verbose = 0;
 
 /* debug support */
@@ -49,7 +49,7 @@
         __FUNCTION__, __LINE__, ##__VA_ARGS__);		\
 	} while (0)
 
-inline void prefetch (const void *x)
+static inline void prefetch (const void *x)
 {
 	__asm volatile("prefetcht0 %0" :: "m" (*(const unsigned long *)x));
 }
@@ -135,13 +135,12 @@
 	PCAP_D_OUT
 } pcap_direction_t;
  
+struct bpf_program;
 
 
 typedef void (*pcap_handler)(u_char *user,
 		const struct pcap_pkthdr *h, const u_char *bytes);
 
-char errbuf[PCAP_ERRBUF_SIZE];
-
 pcap_t *pcap_open_live(const char *device, int snaplen,
                int promisc, int to_ms, char *errbuf);
 
@@ -155,6 +154,24 @@
 int pcap_inject(pcap_t *p, const void *buf, size_t size);
 int pcap_fileno(pcap_t *p);
 const char *pcap_lib_version(void);
+void	pcap_freealldevs(pcap_if_t *);
+pcap_t	*pcap_create(const char *, char *);
+int	pcap_activate(pcap_t *);
+int	pcap_can_set_rfmon(pcap_t *);
+int	pcap_set_snaplen(pcap_t *, int);
+int	pcap_snapshot(pcap_t *);
+int	pcap_lookupnet(const char *, uint32_t *, uint32_t *, char *);
+int	pcap_set_promisc(pcap_t *, int);
+int	pcap_set_timeout(pcap_t *, int);
+int	pcap_compile(pcap_t *, struct bpf_program *, const char *, int,
+	    uint32_t);
+int	pcap_setfilter(pcap_t *, struct bpf_program *);
+int	pcap_datalink(pcap_t *);
+const char *pcap_datalink_val_to_name(int);
+const char *pcap_datalink_val_to_description(int);
+int	pcap_stats(pcap_t *, struct pcap_stat *);
+int	pcap_loop(pcap_t *, int, pcap_handler, u_char *);
+char	*pcap_geterr(pcap_t *);
 
 
 struct eproto {
@@ -201,7 +218,7 @@
 
 
 static int
-do_ioctl(struct my_ring *me, int what)
+do_ioctl(struct my_ring *me, unsigned long what)
 {
 	struct ifreq ifr;
 	int error;
@@ -221,7 +238,7 @@
 	}
 	error = ioctl(me->fd, what, &ifr);
 	if (error) {
-		D("ioctl 0x%x error %d", what, error);
+		D("ioctl 0x%lx error %d", what, error);
 		return error;
 	}
 	switch (what) {
@@ -739,7 +756,8 @@
 #endif /* __PIC__ */
 
 #ifndef __PIC__
-void do_send(u_char *user, const struct pcap_pkthdr *h, const u_char *buf)
+static void
+do_send(u_char *user, const struct pcap_pkthdr *h, const u_char *buf)
 {
 	pcap_inject((pcap_t *)user, buf, h->caplen);
 }
diff -ruN tools/tools/netmap.orig/pkt-gen.c tools/tools/netmap/pkt-gen.c
--- tools/tools/netmap.orig/pkt-gen.c	2013-01-09 01:54:33.000000000 +0100
+++ tools/tools/netmap/pkt-gen.c	2013-01-09 01:54:41.000000000 +0100
@@ -24,7 +24,7 @@
  */
 
 /*
- * $FreeBSD: releng/9.1/tools/tools/netmap/pkt-gen.c 235549 2012-05-17 15:02:51Z luigi $
+ * $FreeBSD: head/tools/tools/netmap/pkt-gen.c 240103 2012-09-04 20:51:25Z emaste $
  * $Id: pkt-gen.c 10967 2012-05-03 11:29:23Z luigi $
  *
  * Example program to show how to build a multithreaded packet
@@ -95,7 +95,7 @@
         __asm volatile("prefetcht0 %0" :: "m" (*(const unsigned long *)x));
 }
 
-// XXX only for multiples of 32 bytes, non overlapped.
+// XXX only for multiples of 64 bytes, non overlapped.
 static inline void
 pkt_copy(void *_src, void *_dst, int l)
 {
@@ -191,6 +191,7 @@
 	struct glob_arg *g;
 	int used;
 	int completed;
+	int cancel;
 	int fd;
 	struct nmreq nmr;
 	struct netmap_if *nifp;
@@ -221,15 +222,8 @@
 static void
 sigint_h(__unused int sig)
 {
-	for (int i = 0; i < global_nthreads; i++) {
-		/* cancel active threads. */
-		if (targs[i].used == 0)
-			continue;
-
-		D("Cancelling thread #%d\n", i);
-		pthread_cancel(targs[i].thread);
-		targs[i].used = 0;
-	}
+	for (int i = 0; i < global_nthreads; i++)
+		targs[i].cancel = 1;
 
 	signal(SIGINT, SIG_DFL);
 }
@@ -474,13 +468,19 @@
 sender_body(void *data)
 {
 	struct targ *targ = (struct targ *) data;
-
 	struct pollfd fds[1];
 	struct netmap_if *nifp = targ->nifp;
 	struct netmap_ring *txring;
-	int i, n = targ->g->npackets / targ->g->nthreads, sent = 0;
+	int i, pkts_per_td = targ->g->npackets / targ->g->nthreads, sent = 0;
+	int continuous = 0;
 	int options = targ->g->options | OPT_COPY;
+	int retval;
+
 D("start");
+	if (pkts_per_td == 0) {
+		continuous = 1;
+		pkts_per_td = 100000;
+	}
 	if (setaffinity(targ->thread, targ->affinity))
 		goto quit;
 	/* setup poll(2) mechanism. */
@@ -495,7 +495,7 @@
 	void *pkt = &targ->pkt;
 	pcap_t *p = targ->g->p;
 
-	for (i = 0; sent < n; i++) {
+	for (i = 0; (sent < pkts_per_td && !targ->cancel) || continuous; i++) {
 		if (pcap_inject(p, pkt, size) != -1)
 			sent++;
 		if (i > 10000) {
@@ -504,13 +504,19 @@
 		}
 	}
     } else {
-	while (sent < n) {
+	while (sent < pkts_per_td || continuous) {
 
 		/*
 		 * wait for available room in the send queue(s)
 		 */
-		if (poll(fds, 1, 2000) <= 0) {
-			D("poll error/timeout on queue %d\n", targ->me);
+		if ((retval = poll(fds, 1, 2000)) <= 0) {
+			if (targ->cancel)
+				break;
+			if (retval == 0)
+				D("poll timeout on queue %d\n", targ->me);
+			else
+				D("poll error on queue %d: %s\n", targ->me,
+				    strerror(errno));
 			goto quit;
 		}
 		/*
@@ -518,8 +524,10 @@
 		 */
 		if (sent > 100000 && !(targ->g->options & OPT_COPY) )
 			options &= ~OPT_COPY;
-		for (i = targ->qfirst; i < targ->qlast; i++) {
-			int m, limit = MIN(n - sent, targ->g->burst);
+		for (i = targ->qfirst; i < targ->qlast && !targ->cancel; i++) {
+			int m, limit = targ->g->burst;
+			if (!continuous && pkts_per_td - sent < limit)
+				limit = pkts_per_td - sent;
 
 			txring = NETMAP_TXRING(nifp, i);
 			if (txring->avail == 0)
@@ -529,6 +537,8 @@
 			sent += m;
 			targ->count = sent;
 		}
+		if (targ->cancel)
+			break; 
 	}
 	/* flush any remaining packets */
 	ioctl(fds[0].fd, NIOCTXSYNC, NULL);
@@ -604,7 +614,7 @@
 	fds[0].events = (POLLIN);
 
 	/* unbounded wait for the first packet. */
-	for (;;) {
+	while (!targ->cancel) {
 		i = poll(fds, 1, 1000);
 		if (i > 0 && !(fds[0].revents & POLLERR))
 			break;
@@ -614,11 +624,11 @@
 	/* main loop, exit after 1s silence */
 	gettimeofday(&targ->tic, NULL);
     if (targ->g->use_pcap) {
-	for (;;) {
+	while (!targ->cancel) {
 		pcap_dispatch(targ->g->p, targ->g->burst, receive_pcap, NULL);
 	}
     } else {
-	while (1) {
+	while (!targ->cancel) {
 		/* Once we started to receive packets, wait at most 1 seconds
 		   before quitting. */
 		if (poll(fds, 1, 1 * 1000) <= 0) {
@@ -655,27 +665,41 @@
 	return (NULL);
 }
 
+static char *
+scaled_val(double val)
+{
+	static char buf[64];
+	const char *units[] = {"", "K", "M", "G"};
+	int i = 0;
+
+	while (val >= 1000 && i < 3) {
+		val /= 1000;
+		i++;
+	}
+	snprintf(buf, sizeof(buf), "%.2f%s", val, units[i]);
+	return (buf);
+}
+
 static void
 tx_output(uint64_t sent, int size, double delta)
 {
-	double amount = 8.0 * (1.0 * size * sent) / delta;
+	uint64_t bytes_sent = sent * size;
+	double bw = 8.0 * bytes_sent / delta;
 	double pps = sent / delta;
-	char units[4] = { '\0', 'K', 'M', 'G' };
-	int aunit = 0, punit = 0;
-
-	while (amount >= 1000) {
-		amount /= 1000;
-		aunit += 1;
-	}
-	while (pps >= 1000) {
-		pps /= 1000;
-		punit += 1;
-	}
+	/*
+	 * Assume Ethernet overhead of 24 bytes per packet excluding header:
+	 * FCS       4 bytes
+	 * Preamble  8 bytes
+	 * IFG      12 bytes
+	 */
+	double bw_with_overhead = 8.0 * (bytes_sent + sent * 24) / delta;
 
 	printf("Sent %" PRIu64 " packets, %d bytes each, in %.2f seconds.\n",
 	       sent, size, delta);
-	printf("Speed: %.2f%cpps. Bandwidth: %.2f%cbps.\n",
-	       pps, units[punit], amount, units[aunit]);
+	printf("Speed: %spps. ", scaled_val(pps));
+	printf("Bandwidth: %sbps ", scaled_val(bw));
+	printf("(%sbps with overhead).\n", scaled_val(bw_with_overhead));
+
 }
 
 
@@ -704,7 +728,7 @@
 		"Usage:\n"
 		"%s arguments\n"
 		"\t-i interface		interface name\n"
-		"\t-t pkts_to_send	also forces send mode\n"
+		"\t-t pkts_to_send	also forces send mode, 0 = continuous\n"
 		"\t-r pkts_to_receive	also forces receive mode\n"
 		"\t-l pkts_size		in bytes excluding CRC\n"
 		"\t-d dst-ip		end with %%n to sweep n addresses\n"
@@ -868,7 +892,7 @@
 	fd = open("/dev/netmap", O_RDWR);
 	if (fd == -1) {
 		D("Unable to open /dev/netmap");
-		// fail later
+		exit(1);
 	} else {
 		if ((ioctl(fd, NIOCGINFO, &nmr)) == -1) {
 			D("Unable to get if info without name");
@@ -1057,7 +1081,7 @@
 		pps = toc.tv_sec* 1000000 + toc.tv_usec;
 		if (pps < 10000)
 			continue;
-		pps = (my_count - prev)*1000000 / pps;
+		pps = ((my_count - prev) * 1000000 + pps / 2) / pps;
 		D("%" PRIu64 " pps", pps);
 		prev = my_count;
 		toc = now;
